<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>gci: molpro::SMat_&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">gci
   &#160;<span id="projectnumber">.</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemolpro.html">molpro</a></li><li class="navelem"><a class="el" href="classmolpro_1_1SMat__.html">SMat_</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classmolpro_1_1SMat__-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">molpro::SMat_&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The SMat class holds the meta-information and a pointer to data for a symmetry-packed matrix object. The <a class="el" href="namespacemolpro.html#ad80f79742f183b105c60b295863d6718">SMat</a> is characterised by the symmetry, parity, and rank of the matrix, and its row and column dimensions in each symmetry.  
 <a href="classmolpro_1_1SMat__.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="SMat_8h_source.html">SMat.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1SMat___1_1SVD.html">SVD</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container for a singular-value decomposition of an SMat.  <a href="classmolpro_1_1SMat___1_1SVD.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a0327b4b21be7f823b70447284ececf11"><td class="memItemLeft" align="right" valign="top">typedef Eigen::Map&lt; Eigen::Matrix&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a>, Eigen::Dynamic, Eigen::Dynamic &gt;, Eigen::Unaligned, Eigen::Stride&lt; Eigen::Dynamic, Eigen::Dynamic &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1SMat__.html#a0327b4b21be7f823b70447284ececf11">M</a></td></tr>
<tr class="separator:a0327b4b21be7f823b70447284ececf11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace72697d7f93c836aa30a2adcdac5f81"><td class="memItemLeft" align="right" valign="top">typedef Eigen::Map&lt; const Eigen::Matrix&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a>, Eigen::Dynamic, Eigen::Dynamic &gt;, Eigen::Unaligned, Eigen::Stride&lt; Eigen::Dynamic, Eigen::Dynamic &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1SMat__.html#ace72697d7f93c836aa30a2adcdac5f81">Mconst</a></td></tr>
<tr class="separator:ace72697d7f93c836aa30a2adcdac5f81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbe220caa385afb70fd47bcbe2be0487"><td class="memItemLeft" align="right" valign="top">typedef Eigen::Map&lt; Eigen::Matrix&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a>, Eigen::Dynamic, 1 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1SMat__.html#abbe220caa385afb70fd47bcbe2be0487">V</a></td></tr>
<tr class="separator:abbe220caa385afb70fd47bcbe2be0487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b0793833395ba3be28166f1d3921341"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1SMat__.html#a0b0793833395ba3be28166f1d3921341">value_type</a> = <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a></td></tr>
<tr class="separator:a0b0793833395ba3be28166f1d3921341"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b8c1114d47d84f7d7ed2924fe11ed23"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1SMat__.html#a8b8c1114d47d84f7d7ed2924fe11ed23">scalar_type</a> = <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a></td></tr>
<tr class="separator:a8b8c1114d47d84f7d7ed2924fe11ed23"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af808f2a29da585e8ebc8dae3ca31c3b0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1SMat__.html#af808f2a29da585e8ebc8dae3ca31c3b0">SMat_</a> (<a class="el" href="namespacemolpro.html#a7a136b7a21c942e40967ed5bab20ff2e">dims_t</a> <a class="el" href="classmolpro_1_1SMat__.html#ad6d93288414fcf17fe589aec43663ea6">dimensions</a>, <a class="el" href="namespacemolpro.html#a77b8d977180296c55c184036b65c5a6f">parity_t</a> <a class="el" href="classmolpro_1_1SMat__.html#a98d3aa28735f6b9767860241b411467d">parity</a>=<a class="el" href="namespacemolpro.html#a77b8d977180296c55c184036b65c5a6fab84d144528f1a54d906ec2d9922f3aec">parityNone</a>, int <a class="el" href="classmolpro_1_1SMat__.html#a547b277343b47bd508c8a1a9b8265917">symmetry</a>=0, bool <a class="el" href="classmolpro_1_1SMat__.html#a37d11915f8ea6ad10c476ec3370d1d33">diagonal</a>=false, std::string description=&quot;&quot;)</td></tr>
<tr class="memdesc:af808f2a29da585e8ebc8dae3ca31c3b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct using explicit symmetry-block dimensions. The data buffer is allocated and maintained internally.  <a href="classmolpro_1_1SMat__.html#af808f2a29da585e8ebc8dae3ca31c3b0">More...</a><br /></td></tr>
<tr class="separator:af808f2a29da585e8ebc8dae3ca31c3b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14857bfc39552244d6778a125f5ecdcd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1SMat__.html#a14857bfc39552244d6778a125f5ecdcd">SMat_</a> (<a class="el" href="namespacemolpro.html#a7a136b7a21c942e40967ed5bab20ff2e">dims_t</a> <a class="el" href="classmolpro_1_1SMat__.html#ad6d93288414fcf17fe589aec43663ea6">dimensions</a>, molpro::array&lt; <a class="el" href="classmolpro_1_1SMat__.html#a0b0793833395ba3be28166f1d3921341">value_type</a> &gt; &amp;buffer, <a class="el" href="namespacemolpro.html#a77b8d977180296c55c184036b65c5a6f">parity_t</a> <a class="el" href="classmolpro_1_1SMat__.html#a98d3aa28735f6b9767860241b411467d">parity</a>=<a class="el" href="namespacemolpro.html#a77b8d977180296c55c184036b65c5a6fab84d144528f1a54d906ec2d9922f3aec">parityNone</a>, int <a class="el" href="classmolpro_1_1SMat__.html#a547b277343b47bd508c8a1a9b8265917">symmetry</a>=0, bool <a class="el" href="classmolpro_1_1SMat__.html#a37d11915f8ea6ad10c476ec3370d1d33">diagonal</a>=false, std::string description=&quot;&quot;)</td></tr>
<tr class="memdesc:a14857bfc39552244d6778a125f5ecdcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct using explicit symmetry-block dimensions.  <a href="classmolpro_1_1SMat__.html#a14857bfc39552244d6778a125f5ecdcd">More...</a><br /></td></tr>
<tr class="separator:a14857bfc39552244d6778a125f5ecdcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcc071139db4f4cb5d9aff40cc816e4f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1SMat__.html#adcc071139db4f4cb5d9aff40cc816e4f">SMat_</a> (<a class="el" href="namespacemolpro.html#a7a136b7a21c942e40967ed5bab20ff2e">dims_t</a> <a class="el" href="classmolpro_1_1SMat__.html#ad6d93288414fcf17fe589aec43663ea6">dimensions</a>, <a class="el" href="classmolpro_1_1SMat__.html#a0b0793833395ba3be28166f1d3921341">value_type</a> *buffer, <a class="el" href="namespacemolpro.html#a77b8d977180296c55c184036b65c5a6f">parity_t</a> <a class="el" href="classmolpro_1_1SMat__.html#a98d3aa28735f6b9767860241b411467d">parity</a>=<a class="el" href="namespacemolpro.html#a77b8d977180296c55c184036b65c5a6fab84d144528f1a54d906ec2d9922f3aec">parityNone</a>, int <a class="el" href="classmolpro_1_1SMat__.html#a547b277343b47bd508c8a1a9b8265917">symmetry</a>=0, bool <a class="el" href="classmolpro_1_1SMat__.html#a37d11915f8ea6ad10c476ec3370d1d33">diagonal</a>=false, std::string description=&quot;&quot;)</td></tr>
<tr class="memdesc:adcc071139db4f4cb5d9aff40cc816e4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct using explicit symmetry-block dimensions.  <a href="classmolpro_1_1SMat__.html#adcc071139db4f4cb5d9aff40cc816e4f">More...</a><br /></td></tr>
<tr class="separator:adcc071139db4f4cb5d9aff40cc816e4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad75df24c8852f5384bf3e61fcbc0c1f6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1SMat__.html#ad75df24c8852f5384bf3e61fcbc0c1f6">SMat_</a> (std::string space, <a class="el" href="namespacemolpro.html#a77b8d977180296c55c184036b65c5a6f">parity_t</a> <a class="el" href="classmolpro_1_1SMat__.html#a98d3aa28735f6b9767860241b411467d">parity</a>=<a class="el" href="namespacemolpro.html#a77b8d977180296c55c184036b65c5a6fab84d144528f1a54d906ec2d9922f3aec">parityNone</a>, int <a class="el" href="classmolpro_1_1SMat__.html#a547b277343b47bd508c8a1a9b8265917">symmetry</a>=0, bool <a class="el" href="classmolpro_1_1SMat__.html#a37d11915f8ea6ad10c476ec3370d1d33">diagonal</a>=false, std::string description=&quot;&quot;)</td></tr>
<tr class="memdesc:ad75df24c8852f5384bf3e61fcbc0c1f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct using symmetry-block dimensions obtained from standard orbital space definitions. The data buffer is allocated and maintained internally.  <a href="classmolpro_1_1SMat__.html#ad75df24c8852f5384bf3e61fcbc0c1f6">More...</a><br /></td></tr>
<tr class="separator:ad75df24c8852f5384bf3e61fcbc0c1f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64bd7f74bbc04f1c3ab4f4f900fe86cd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1SMat__.html#a64bd7f74bbc04f1c3ab4f4f900fe86cd">SMat_</a> (std::string space, molpro::array&lt; <a class="el" href="classmolpro_1_1SMat__.html#a0b0793833395ba3be28166f1d3921341">value_type</a> &gt; &amp;buffer, <a class="el" href="namespacemolpro.html#a77b8d977180296c55c184036b65c5a6f">parity_t</a> <a class="el" href="classmolpro_1_1SMat__.html#a98d3aa28735f6b9767860241b411467d">parity</a>=<a class="el" href="namespacemolpro.html#a77b8d977180296c55c184036b65c5a6fab84d144528f1a54d906ec2d9922f3aec">parityNone</a>, int <a class="el" href="classmolpro_1_1SMat__.html#a547b277343b47bd508c8a1a9b8265917">symmetry</a>=0, bool <a class="el" href="classmolpro_1_1SMat__.html#a37d11915f8ea6ad10c476ec3370d1d33">diagonal</a>=false, std::string description=&quot;&quot;)</td></tr>
<tr class="memdesc:a64bd7f74bbc04f1c3ab4f4f900fe86cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct using symmetry-block dimensions obtained from standard orbital space definitions.  <a href="classmolpro_1_1SMat__.html#a64bd7f74bbc04f1c3ab4f4f900fe86cd">More...</a><br /></td></tr>
<tr class="separator:a64bd7f74bbc04f1c3ab4f4f900fe86cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39e4d9da3065b19a3c0d8b9ae98ed3c3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1SMat__.html#a39e4d9da3065b19a3c0d8b9ae98ed3c3">SMat_</a> (std::string space, <a class="el" href="classmolpro_1_1SMat__.html#a0b0793833395ba3be28166f1d3921341">value_type</a> *buffer, <a class="el" href="namespacemolpro.html#a77b8d977180296c55c184036b65c5a6f">parity_t</a> <a class="el" href="classmolpro_1_1SMat__.html#a98d3aa28735f6b9767860241b411467d">parity</a>=<a class="el" href="namespacemolpro.html#a77b8d977180296c55c184036b65c5a6fab84d144528f1a54d906ec2d9922f3aec">parityNone</a>, int <a class="el" href="classmolpro_1_1SMat__.html#a547b277343b47bd508c8a1a9b8265917">symmetry</a>=0, bool <a class="el" href="classmolpro_1_1SMat__.html#a37d11915f8ea6ad10c476ec3370d1d33">diagonal</a>=false, std::string description=&quot;&quot;)</td></tr>
<tr class="memdesc:a39e4d9da3065b19a3c0d8b9ae98ed3c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct using symmetry-block dimensions obtained from standard orbital space definitions.  <a href="classmolpro_1_1SMat__.html#a39e4d9da3065b19a3c0d8b9ae98ed3c3">More...</a><br /></td></tr>
<tr class="separator:a39e4d9da3065b19a3c0d8b9ae98ed3c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2cc7af6ba16f310f745724129d5c932"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1SMat__.html#af2cc7af6ba16f310f745724129d5c932">SMat_</a> (<a class="el" href="classmolpro_1_1SMat__.html">SMat_</a> const *source, <a class="el" href="namespacemolpro.html#a77b8d977180296c55c184036b65c5a6f">parity_t</a> <a class="el" href="classmolpro_1_1SMat__.html#a98d3aa28735f6b9767860241b411467d">parity</a>=<a class="el" href="namespacemolpro.html#a77b8d977180296c55c184036b65c5a6fa36d4c7d8181c3d6fc1f1519c27b6e543">parityUnspecified</a>, int <a class="el" href="classmolpro_1_1SMat__.html#a547b277343b47bd508c8a1a9b8265917">symmetry</a>=9, unsigned int <a class="el" href="classmolpro_1_1SMat__.html#a1afadd176dc7464b07ba2e3b7910f0d7">rank</a>=0, bool <a class="el" href="classmolpro_1_1SMat__.html#a37d11915f8ea6ad10c476ec3370d1d33">diagonal</a>=false, std::string description=&quot;&quot;)</td></tr>
<tr class="memdesc:af2cc7af6ba16f310f745724129d5c932"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct <a class="el" href="namespacemolpro.html#ad80f79742f183b105c60b295863d6718">SMat</a> templated by another <a class="el" href="namespacemolpro.html#ad80f79742f183b105c60b295863d6718">SMat</a>. The actual data are not copied. The new data buffer is allocated and maintained internally.  <a href="classmolpro_1_1SMat__.html#af2cc7af6ba16f310f745724129d5c932">More...</a><br /></td></tr>
<tr class="separator:af2cc7af6ba16f310f745724129d5c932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1ee4ed1ddc82c615d84b96af006f99c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1SMat__.html#aa1ee4ed1ddc82c615d84b96af006f99c">SMat_</a> (<a class="el" href="classmolpro_1_1SMat__.html">SMat_</a> const *source, molpro::array&lt; <a class="el" href="classmolpro_1_1SMat__.html#a0b0793833395ba3be28166f1d3921341">value_type</a> &gt; &amp;buffer, <a class="el" href="namespacemolpro.html#a77b8d977180296c55c184036b65c5a6f">parity_t</a> <a class="el" href="classmolpro_1_1SMat__.html#a98d3aa28735f6b9767860241b411467d">parity</a>=<a class="el" href="namespacemolpro.html#a77b8d977180296c55c184036b65c5a6fa36d4c7d8181c3d6fc1f1519c27b6e543">parityUnspecified</a>, int <a class="el" href="classmolpro_1_1SMat__.html#a547b277343b47bd508c8a1a9b8265917">symmetry</a>=9, unsigned int <a class="el" href="classmolpro_1_1SMat__.html#a1afadd176dc7464b07ba2e3b7910f0d7">rank</a>=0, bool <a class="el" href="classmolpro_1_1SMat__.html#a37d11915f8ea6ad10c476ec3370d1d33">diagonal</a>=false, std::string description=&quot;&quot;)</td></tr>
<tr class="memdesc:aa1ee4ed1ddc82c615d84b96af006f99c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct <a class="el" href="namespacemolpro.html#ad80f79742f183b105c60b295863d6718">SMat</a> templated by another <a class="el" href="namespacemolpro.html#ad80f79742f183b105c60b295863d6718">SMat</a>. The actual data are not copied.  <a href="classmolpro_1_1SMat__.html#aa1ee4ed1ddc82c615d84b96af006f99c">More...</a><br /></td></tr>
<tr class="separator:aa1ee4ed1ddc82c615d84b96af006f99c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82319192daa2d0194d4c8e6f56155632"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1SMat__.html#a82319192daa2d0194d4c8e6f56155632">SMat_</a> (<a class="el" href="classmolpro_1_1SMat__.html">SMat_</a> const *source, <a class="el" href="classmolpro_1_1SMat__.html#a0b0793833395ba3be28166f1d3921341">value_type</a> *buffer, <a class="el" href="namespacemolpro.html#a77b8d977180296c55c184036b65c5a6f">parity_t</a> <a class="el" href="classmolpro_1_1SMat__.html#a98d3aa28735f6b9767860241b411467d">parity</a>, int <a class="el" href="classmolpro_1_1SMat__.html#a547b277343b47bd508c8a1a9b8265917">symmetry</a>=9, unsigned int <a class="el" href="classmolpro_1_1SMat__.html#a1afadd176dc7464b07ba2e3b7910f0d7">rank</a>=0, bool <a class="el" href="classmolpro_1_1SMat__.html#a37d11915f8ea6ad10c476ec3370d1d33">diagonal</a>=false, std::string description=&quot;&quot;)</td></tr>
<tr class="memdesc:a82319192daa2d0194d4c8e6f56155632"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct <a class="el" href="namespacemolpro.html#ad80f79742f183b105c60b295863d6718">SMat</a> templated by another <a class="el" href="namespacemolpro.html#ad80f79742f183b105c60b295863d6718">SMat</a>. The actual data are not copied.  <a href="classmolpro_1_1SMat__.html#a82319192daa2d0194d4c8e6f56155632">More...</a><br /></td></tr>
<tr class="separator:a82319192daa2d0194d4c8e6f56155632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab99b3114ed6ddaeea1d471048aaf39ca"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1SMat__.html#ab99b3114ed6ddaeea1d471048aaf39ca">SMat_</a> (<a class="el" href="classmolpro_1_1SMat__.html">SMat_</a> const &amp;source, int option=0)</td></tr>
<tr class="memdesc:ab99b3114ed6ddaeea1d471048aaf39ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="classmolpro_1_1SMat__.html#ab99b3114ed6ddaeea1d471048aaf39ca">More...</a><br /></td></tr>
<tr class="separator:ab99b3114ed6ddaeea1d471048aaf39ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a4f9846a6de8a97218b002256490d5d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1SMat__.html#a6a4f9846a6de8a97218b002256490d5d">SMat_</a> (const char *dump, <a class="el" href="classmolpro_1_1SMat__.html#a0b0793833395ba3be28166f1d3921341">value_type</a> *buffer=nullptr)</td></tr>
<tr class="memdesc:a6a4f9846a6de8a97218b002256490d5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an object from what is produced by <a class="el" href="classmolpro_1_1SMat__.html#a957ab00af39f9506b9115df9cfacc561" title="Serialise the object to a stream of bytes.">bytestream()</a>. If the bytestream contains data, it will be loaded, otherwise the contents of the object are undefined, and only the dimensions and parameters are loaded.  <a href="classmolpro_1_1SMat__.html#a6a4f9846a6de8a97218b002256490d5d">More...</a><br /></td></tr>
<tr class="separator:a6a4f9846a6de8a97218b002256490d5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ca0b0ca854905e53878e6be96c994dc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1SMat__.html#a7ca0b0ca854905e53878e6be96c994dc">SMat_</a> (const molpro::bytestream &amp;bs, <a class="el" href="classmolpro_1_1SMat__.html#a0b0793833395ba3be28166f1d3921341">value_type</a> *buffer=nullptr)</td></tr>
<tr class="memdesc:a7ca0b0ca854905e53878e6be96c994dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an object from what is produced by <a class="el" href="classmolpro_1_1SMat__.html#a957ab00af39f9506b9115df9cfacc561" title="Serialise the object to a stream of bytes.">bytestream()</a>. If the bytestream contains data, it will be loaded, otherwise the contents of the object are undefined, and only the dimensions and parameters are loaded.  <a href="classmolpro_1_1SMat__.html#a7ca0b0ca854905e53878e6be96c994dc">More...</a><br /></td></tr>
<tr class="separator:a7ca0b0ca854905e53878e6be96c994dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5df30e81a0c10dd11c3f3c1d525459fa"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1SMat__.html#a5df30e81a0c10dd11c3f3c1d525459fa">~SMat_</a> ()</td></tr>
<tr class="separator:a5df30e81a0c10dd11c3f3c1d525459fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a101b66c8de2e0ebf4525078e77c02102"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmolpro_1_1SMat__.html">SMat_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1SMat__.html#a101b66c8de2e0ebf4525078e77c02102">operator=</a> (<a class="el" href="classmolpro_1_1SMat__.html">SMat_</a> const &amp;source)</td></tr>
<tr class="memdesc:a101b66c8de2e0ebf4525078e77c02102"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy an SMat, if necessary converting parity. If the copy is from square to triangular, the parity of the result is enforced, ie half <code>in</code> plus or minus the transpose of <code>in</code> is constructed. If the dimensions of source and destination do not match, only addresses valid in source and destination will be copied.  <a href="classmolpro_1_1SMat__.html#a101b66c8de2e0ebf4525078e77c02102">More...</a><br /></td></tr>
<tr class="separator:a101b66c8de2e0ebf4525078e77c02102"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8772e70926c11c6018ea80b84a2ba410"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmolpro_1_1SMat__.html">SMat_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1SMat__.html#a8772e70926c11c6018ea80b84a2ba410">copy</a> (<a class="el" href="classmolpro_1_1SMat__.html">SMat_</a> const &amp;source, <a class="el" href="namespacemolpro.html#a7a136b7a21c942e40967ed5bab20ff2e">dims_t</a> sourceOffset={{0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}})</td></tr>
<tr class="memdesc:a8772e70926c11c6018ea80b84a2ba410"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy an SMat, if necessary converting parity, and with the possibility of a positive offset in the source row and column indices. If the copy is from square to triangular, the parity of the result is enforced, ie half <code>in</code> plus or minus the transpose of <code>in</code> is constructed. If the dimensions of source and destination do not match, only addresses valid in source and destination will be copied.  <a href="classmolpro_1_1SMat__.html#a8772e70926c11c6018ea80b84a2ba410">More...</a><br /></td></tr>
<tr class="separator:a8772e70926c11c6018ea80b84a2ba410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d0e1b4ebd809e20903c469937e6037a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1SMat__.html#a5d0e1b4ebd809e20903c469937e6037a">splice</a> (<a class="el" href="classmolpro_1_1SMat__.html">SMat_</a> const &amp;source, <a class="el" href="namespacemolpro.html#a7a136b7a21c942e40967ed5bab20ff2e">dims_t</a> sourceOffset={{0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}}, <a class="el" href="namespacemolpro.html#a7a136b7a21c942e40967ed5bab20ff2e">dims_t</a> offset={{0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}})</td></tr>
<tr class="memdesc:a5d0e1b4ebd809e20903c469937e6037a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy part or all of another SMat object, corresponding to a reduced range of indices, into this one. The copy range for either rows or columns is restricted so that it lies within both the source and destination.  <a href="classmolpro_1_1SMat__.html#a5d0e1b4ebd809e20903c469937e6037a">More...</a><br /></td></tr>
<tr class="separator:a5d0e1b4ebd809e20903c469937e6037a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa430910cb57918a059992d8e1345e5f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmolpro_1_1SMat__.html">SMat_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1SMat__.html#aa430910cb57918a059992d8e1345e5f2">slice</a> (<a class="el" href="namespacemolpro.html#a7a136b7a21c942e40967ed5bab20ff2e">dims_t</a> <a class="el" href="classmolpro_1_1SMat__.html#ad6d93288414fcf17fe589aec43663ea6">dimensions</a>, <a class="el" href="namespacemolpro.html#a7a136b7a21c942e40967ed5bab20ff2e">dims_t</a> offset={{0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}}, std::string description=&quot;&quot;)</td></tr>
<tr class="memdesc:aa430910cb57918a059992d8e1345e5f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new SMat as a copy of a submatrix of this one.  <a href="classmolpro_1_1SMat__.html#aa430910cb57918a059992d8e1345e5f2">More...</a><br /></td></tr>
<tr class="separator:aa430910cb57918a059992d8e1345e5f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a212e6a6d64b026ba600d5ea713c78604"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmolpro_1_1SMat__.html">SMat_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1SMat__.html#a212e6a6d64b026ba600d5ea713c78604">operator*=</a> (<a class="el" href="classmolpro_1_1SMat__.html#a0b0793833395ba3be28166f1d3921341">value_type</a> a)</td></tr>
<tr class="separator:a212e6a6d64b026ba600d5ea713c78604"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a209f34cc5b42189ac62b3b37d4f38ecf"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classmolpro_1_1SMat__.html">SMat_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1SMat__.html#a209f34cc5b42189ac62b3b37d4f38ecf">operator*</a> (<a class="el" href="classmolpro_1_1SMat__.html#a0b0793833395ba3be28166f1d3921341">value_type</a> a) const</td></tr>
<tr class="separator:a209f34cc5b42189ac62b3b37d4f38ecf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41ad7a4c85c10e0964c02b18d1a93ec7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmolpro_1_1SMat__.html">SMat_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1SMat__.html#a41ad7a4c85c10e0964c02b18d1a93ec7">operator+=</a> (<a class="el" href="classmolpro_1_1SMat__.html">SMat_</a> const &amp;other)</td></tr>
<tr class="separator:a41ad7a4c85c10e0964c02b18d1a93ec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a085817f06053ef9175e2b6d065fec4c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmolpro_1_1SMat__.html">SMat_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1SMat__.html#a085817f06053ef9175e2b6d065fec4c5">operator-=</a> (<a class="el" href="classmolpro_1_1SMat__.html">SMat_</a> const &amp;other)</td></tr>
<tr class="separator:a085817f06053ef9175e2b6d065fec4c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa584ea3281c6576f0c07bb5de13430f0"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classmolpro_1_1SMat__.html">SMat_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1SMat__.html#aa584ea3281c6576f0c07bb5de13430f0">operator+</a> (<a class="el" href="classmolpro_1_1SMat__.html">SMat_</a> const &amp;other) const</td></tr>
<tr class="separator:aa584ea3281c6576f0c07bb5de13430f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0db33e2542b6c7dd946fc3078b7fe337"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classmolpro_1_1SMat__.html">SMat_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1SMat__.html#a0db33e2542b6c7dd946fc3078b7fe337">operator-</a> (<a class="el" href="classmolpro_1_1SMat__.html">SMat_</a> const &amp;other) const</td></tr>
<tr class="separator:a0db33e2542b6c7dd946fc3078b7fe337"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5accc02756a9ed0c1f49a98a8d88704b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classmolpro_1_1SMat__.html">SMat_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1SMat__.html#a5accc02756a9ed0c1f49a98a8d88704b">operator*</a> (<a class="el" href="classmolpro_1_1SMat__.html">SMat_</a> const &amp;other) const</td></tr>
<tr class="memdesc:a5accc02756a9ed0c1f49a98a8d88704b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply two SMat objects with contraction such that the result is another SMat. Depending on the ranks of the sources, the possible paradigms are.  <a href="classmolpro_1_1SMat__.html#a5accc02756a9ed0c1f49a98a8d88704b">More...</a><br /></td></tr>
<tr class="separator:a5accc02756a9ed0c1f49a98a8d88704b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45ef1bf1087620d03f86ee3c8f111671"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1SMat__.html#a45ef1bf1087620d03f86ee3c8f111671">multiply</a> (<a class="el" href="classmolpro_1_1SMat__.html">SMat_</a> const &amp;a, <a class="el" href="classmolpro_1_1SMat__.html">SMat_</a> const &amp;b, <a class="el" href="classmolpro_1_1SMat__.html#a0b0793833395ba3be28166f1d3921341">value_type</a> alpha=1.0, <a class="el" href="classmolpro_1_1SMat__.html#a0b0793833395ba3be28166f1d3921341">value_type</a> beta=0.0)</td></tr>
<tr class="memdesc:a45ef1bf1087620d03f86ee3c8f111671"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply two SMat objects with contraction such that the result is another SMat, which will be placed in the current object, which must have the correct dimensions. Depending on the ranks of the sources, the possible paradigms are.  <a href="classmolpro_1_1SMat__.html#a45ef1bf1087620d03f86ee3c8f111671">More...</a><br /></td></tr>
<tr class="separator:a45ef1bf1087620d03f86ee3c8f111671"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb9f39683496e90b66f1a5a2f30a6347"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmolpro_1_1SMat__.html#a8b8c1114d47d84f7d7ed2924fe11ed23">scalar_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1SMat__.html#acb9f39683496e90b66f1a5a2f30a6347">operator&amp;</a> (<a class="el" href="classmolpro_1_1SMat__.html">SMat_</a> const &amp;other) const</td></tr>
<tr class="memdesc:acb9f39683496e90b66f1a5a2f30a6347"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply two SMat objects with contraction such that the result is a scalar scalar_type. Depending on the ranks of the sources, the possible paradigms are.  <a href="classmolpro_1_1SMat__.html#acb9f39683496e90b66f1a5a2f30a6347">More...</a><br /></td></tr>
<tr class="separator:acb9f39683496e90b66f1a5a2f30a6347"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa878713a29c0844e2cd3872156a3bc30"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1SMat__.html#aa878713a29c0844e2cd3872156a3bc30">transpose</a> ()</td></tr>
<tr class="memdesc:aa878713a29c0844e2cd3872156a3bc30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transpose the object. The implementation does not touch the data, but internally marks the state as transposed, affecting the results of subsequent calls to <a class="el" href="classmolpro_1_1SMat__.html#ab2bff361bef7e21e8d5559c84f1149e5" title="Whether or not a particular symmetry block is stored as the transpose.">block_transposed()</a> and <a class="el" href="classmolpro_1_1SMat__.html#ab93b3f5593b33760619295753b5d59d5" title="Get the dimensions of a symmetry block in the buffer.">block_dimensions()</a>.  <a href="classmolpro_1_1SMat__.html#aa878713a29c0844e2cd3872156a3bc30">More...</a><br /></td></tr>
<tr class="separator:aa878713a29c0844e2cd3872156a3bc30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02746993eafa2f8bc9c473a7bf7faba1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1SMat__.html#a02746993eafa2f8bc9c473a7bf7faba1">eval</a> ()</td></tr>
<tr class="memdesc:a02746993eafa2f8bc9c473a7bf7faba1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate, including explicitly transposing if necessary.  <a href="classmolpro_1_1SMat__.html#a02746993eafa2f8bc9c473a7bf7faba1">More...</a><br /></td></tr>
<tr class="separator:a02746993eafa2f8bc9c473a7bf7faba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2942690c1327698fa56541091033d9b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1SMat__.html#a2942690c1327698fa56541091033d9b4">trim</a> (<a class="el" href="classmolpro_1_1SMat__.html#a8b8c1114d47d84f7d7ed2924fe11ed23">scalar_type</a> cut=0)</td></tr>
<tr class="memdesc:a2942690c1327698fa56541091033d9b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set to zero all elements of the object whose absolute value is less than a specified threshold.  <a href="classmolpro_1_1SMat__.html#a2942690c1327698fa56541091033d9b4">More...</a><br /></td></tr>
<tr class="separator:a2942690c1327698fa56541091033d9b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96a34d65a3c485318a1d38a7b185b326"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1SMat__.html#a96a34d65a3c485318a1d38a7b185b326">operator==</a> (<a class="el" href="classmolpro_1_1SMat__.html">SMat_</a> const &amp;other) const</td></tr>
<tr class="memdesc:a96a34d65a3c485318a1d38a7b185b326"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test whether two objects are equal.  <a href="classmolpro_1_1SMat__.html#a96a34d65a3c485318a1d38a7b185b326">More...</a><br /></td></tr>
<tr class="separator:a96a34d65a3c485318a1d38a7b185b326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cb7ca96f47fff37ac68d4fa86ef9118"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1SMat__.html#a8cb7ca96f47fff37ac68d4fa86ef9118">operator!=</a> (<a class="el" href="classmolpro_1_1SMat__.html">SMat_</a> const &amp;other) const</td></tr>
<tr class="separator:a8cb7ca96f47fff37ac68d4fa86ef9118"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54ad673f1ae269ec9777255219d74d20"><td class="memItemLeft" align="right" valign="top">molpro::array&lt; <a class="el" href="classmolpro_1_1SMat__.html#a0b0793833395ba3be28166f1d3921341">value_type</a> &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1SMat__.html#a54ad673f1ae269ec9777255219d74d20">data</a> () const</td></tr>
<tr class="memdesc:a54ad673f1ae269ec9777255219d74d20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a pointer to the raw data.  <a href="classmolpro_1_1SMat__.html#a54ad673f1ae269ec9777255219d74d20">More...</a><br /></td></tr>
<tr class="separator:a54ad673f1ae269ec9777255219d74d20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a250d4fcd59dd037c272d272fa0a0ca07"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1SMat__.html#a250d4fcd59dd037c272d272fa0a0ca07">SMat_</a> ()</td></tr>
<tr class="memdesc:a250d4fcd59dd037c272d272fa0a0ca07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construction of an empty <a class="el" href="namespacemolpro.html#ad80f79742f183b105c60b295863d6718">SMat</a> is allowed to support those clients that need it, but the result is not meaningfully usable.  <a href="classmolpro_1_1SMat__.html#a250d4fcd59dd037c272d272fa0a0ca07">More...</a><br /></td></tr>
<tr class="separator:a250d4fcd59dd037c272d272fa0a0ca07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1598222c5621f038a6f8260f149f1e68"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1SMat__.html#a1598222c5621f038a6f8260f149f1e68">SMat_</a> (const std::map&lt; size_t, <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt; &amp;source)</td></tr>
<tr class="separator:a1598222c5621f038a6f8260f149f1e68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f0818703e5fd58522ef17775f5b5d0a"><td class="memItemLeft" align="right" valign="top">std::map&lt; size_t, <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1SMat__.html#a0f0818703e5fd58522ef17775f5b5d0a">select_max_dot</a> (size_t n, const <a class="el" href="classmolpro_1_1SMat__.html">SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt; &amp;y) const</td></tr>
<tr class="separator:a0f0818703e5fd58522ef17775f5b5d0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4bf47ca6cca88fa5459d23462d93e1e"><td class="memItemLeft" align="right" valign="top">std::map&lt; size_t, <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1SMat__.html#aa4bf47ca6cca88fa5459d23462d93e1e">select_max_dot</a> (size_t n, const std::map&lt; size_t, <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt; &amp;y) const</td></tr>
<tr class="separator:aa4bf47ca6cca88fa5459d23462d93e1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af98b315200c9f4b18ae4dd4737636371"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmolpro_1_1SMat__.html">SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1SMat__.html#af98b315200c9f4b18ae4dd4737636371">operator=</a> (const std::map&lt; size_t, <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt; &amp;source)</td></tr>
<tr class="separator:af98b315200c9f4b18ae4dd4737636371"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a991324ba20fa8d9dfedd0e39570e7d5e"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1SMat__.html#a991324ba20fa8d9dfedd0e39570e7d5e">size</a> () const</td></tr>
<tr class="memdesc:a991324ba20fa8d9dfedd0e39570e7d5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the buffer size of an <a class="el" href="namespacemolpro.html#ad80f79742f183b105c60b295863d6718">SMat</a> object.  <a href="classmolpro_1_1SMat__.html#a991324ba20fa8d9dfedd0e39570e7d5e">More...</a><br /></td></tr>
<tr class="separator:a991324ba20fa8d9dfedd0e39570e7d5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8539a7cb4cbe5a826ab5702b692565f2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1SMat__.html#a8539a7cb4cbe5a826ab5702b692565f2">max_symmetry</a> () const</td></tr>
<tr class="memdesc:a8539a7cb4cbe5a826ab5702b692565f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum symmetry of the object, i.e. the symmetry index above which all dimensions are zero and are impossible to reach by direct products.  <a href="classmolpro_1_1SMat__.html#a8539a7cb4cbe5a826ab5702b692565f2">More...</a><br /></td></tr>
<tr class="separator:a8539a7cb4cbe5a826ab5702b692565f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a547b277343b47bd508c8a1a9b8265917"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1SMat__.html#a547b277343b47bd508c8a1a9b8265917">symmetry</a> () const</td></tr>
<tr class="memdesc:a547b277343b47bd508c8a1a9b8265917"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the symmetry of the object  <a href="classmolpro_1_1SMat__.html#a547b277343b47bd508c8a1a9b8265917">More...</a><br /></td></tr>
<tr class="separator:a547b277343b47bd508c8a1a9b8265917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98d3aa28735f6b9767860241b411467d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemolpro.html#a77b8d977180296c55c184036b65c5a6f">parity_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1SMat__.html#a98d3aa28735f6b9767860241b411467d">parity</a> () const</td></tr>
<tr class="memdesc:a98d3aa28735f6b9767860241b411467d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The parity of the object.  <a href="classmolpro_1_1SMat__.html#a98d3aa28735f6b9767860241b411467d">More...</a><br /></td></tr>
<tr class="separator:a98d3aa28735f6b9767860241b411467d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b326d37c967bd710614bfbfe5d9b039"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1SMat__.html#a6b326d37c967bd710614bfbfe5d9b039">transposed</a> () const</td></tr>
<tr class="memdesc:a6b326d37c967bd710614bfbfe5d9b039"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the <a class="el" href="namespacemolpro.html#ad80f79742f183b105c60b295863d6718">SMat</a> is transposed.  <a href="classmolpro_1_1SMat__.html#a6b326d37c967bd710614bfbfe5d9b039">More...</a><br /></td></tr>
<tr class="separator:a6b326d37c967bd710614bfbfe5d9b039"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a202742845c62542a214f49fd56768b4b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1SMat__.html#a202742845c62542a214f49fd56768b4b">Diagonal</a> () const</td></tr>
<tr class="memdesc:a202742845c62542a214f49fd56768b4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the <a class="el" href="namespacemolpro.html#ad80f79742f183b105c60b295863d6718">SMat</a> is diagonal.  <a href="classmolpro_1_1SMat__.html#a202742845c62542a214f49fd56768b4b">More...</a><br /></td></tr>
<tr class="separator:a202742845c62542a214f49fd56768b4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a341a13f8db182f9827f4bda1160a287f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1SMat__.html#a341a13f8db182f9827f4bda1160a287f">dimension</a> (unsigned int block_symmetry=0, unsigned int axis=0) const</td></tr>
<tr class="memdesc:a341a13f8db182f9827f4bda1160a287f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a dimension of a symmetry block.  <a href="classmolpro_1_1SMat__.html#a341a13f8db182f9827f4bda1160a287f">More...</a><br /></td></tr>
<tr class="separator:a341a13f8db182f9827f4bda1160a287f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1afadd176dc7464b07ba2e3b7910f0d7"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1SMat__.html#a1afadd176dc7464b07ba2e3b7910f0d7">rank</a> () const</td></tr>
<tr class="memdesc:a1afadd176dc7464b07ba2e3b7910f0d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the rank of the object.  <a href="classmolpro_1_1SMat__.html#a1afadd176dc7464b07ba2e3b7910f0d7">More...</a><br /></td></tr>
<tr class="separator:a1afadd176dc7464b07ba2e3b7910f0d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50567b48730e40fbc63a98c503412acc"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1SMat__.html#a50567b48730e40fbc63a98c503412acc">block_size</a> (unsigned int block_symmetry) const</td></tr>
<tr class="memdesc:a50567b48730e40fbc63a98c503412acc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size of a symmetry block.  <a href="classmolpro_1_1SMat__.html#a50567b48730e40fbc63a98c503412acc">More...</a><br /></td></tr>
<tr class="separator:a50567b48730e40fbc63a98c503412acc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac645aaea1fb648500512ab87e7a727a6"><td class="memItemLeft" align="right" valign="top">molpro::array&lt; <a class="el" href="classmolpro_1_1SMat__.html#a0b0793833395ba3be28166f1d3921341">value_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1SMat__.html#ac645aaea1fb648500512ab87e7a727a6">block</a> (unsigned int block_symmetry) const</td></tr>
<tr class="memdesc:ac645aaea1fb648500512ab87e7a727a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a container pointing to a symmetry block.  <a href="classmolpro_1_1SMat__.html#ac645aaea1fb648500512ab87e7a727a6">More...</a><br /></td></tr>
<tr class="separator:ac645aaea1fb648500512ab87e7a727a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab93b3f5593b33760619295753b5d59d5"><td class="memItemLeft" align="right" valign="top">std::vector&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1SMat__.html#ab93b3f5593b33760619295753b5d59d5">block_dimensions</a> (unsigned int block_symmetry) const</td></tr>
<tr class="memdesc:ab93b3f5593b33760619295753b5d59d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the dimensions of a symmetry block in the buffer.  <a href="classmolpro_1_1SMat__.html#ab93b3f5593b33760619295753b5d59d5">More...</a><br /></td></tr>
<tr class="separator:ab93b3f5593b33760619295753b5d59d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6d93288414fcf17fe589aec43663ea6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemolpro.html#a7a136b7a21c942e40967ed5bab20ff2e">dims_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1SMat__.html#ad6d93288414fcf17fe589aec43663ea6">dimensions</a> () const</td></tr>
<tr class="separator:ad6d93288414fcf17fe589aec43663ea6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2bff361bef7e21e8d5559c84f1149e5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1SMat__.html#ab2bff361bef7e21e8d5559c84f1149e5">block_transposed</a> (unsigned int block_symmetry) const</td></tr>
<tr class="memdesc:ab2bff361bef7e21e8d5559c84f1149e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether or not a particular symmetry block is stored as the transpose.  <a href="classmolpro_1_1SMat__.html#ab2bff361bef7e21e8d5559c84f1149e5">More...</a><br /></td></tr>
<tr class="separator:ab2bff361bef7e21e8d5559c84f1149e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f9e9a4b80130050227a951867384dd3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmolpro_1_1SMat__.html#a0b0793833395ba3be28166f1d3921341">value_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1SMat__.html#a5f9e9a4b80130050227a951867384dd3">trace</a> () const</td></tr>
<tr class="memdesc:a5f9e9a4b80130050227a951867384dd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the trace of a matrix.  <a href="classmolpro_1_1SMat__.html#a5f9e9a4b80130050227a951867384dd3">More...</a><br /></td></tr>
<tr class="separator:a5f9e9a4b80130050227a951867384dd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87da40b6dc99e6121a56a268e5cb7d89"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmolpro_1_1SMat__.html#a8b8c1114d47d84f7d7ed2924fe11ed23">scalar_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1SMat__.html#a87da40b6dc99e6121a56a268e5cb7d89">norm</a> () const</td></tr>
<tr class="memdesc:a87da40b6dc99e6121a56a268e5cb7d89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the norm. For vectors, it is the L2-norm; for matrices, the square root of the sum of the matrix elements.  <a href="classmolpro_1_1SMat__.html#a87da40b6dc99e6121a56a268e5cb7d89">More...</a><br /></td></tr>
<tr class="separator:a87da40b6dc99e6121a56a268e5cb7d89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79992ebc8adb0f55ccbfcae9298cf496"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1SMat__.html#a79992ebc8adb0f55ccbfcae9298cf496">assign</a> (<a class="el" href="classmolpro_1_1SMat__.html#a0b0793833395ba3be28166f1d3921341">value_type</a> value)</td></tr>
<tr class="memdesc:a79992ebc8adb0f55ccbfcae9298cf496"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the elements of the matrix to a value.  <a href="classmolpro_1_1SMat__.html#a79992ebc8adb0f55ccbfcae9298cf496">More...</a><br /></td></tr>
<tr class="separator:a79992ebc8adb0f55ccbfcae9298cf496"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b183f6027e4dd11375d990fb8d7f008"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1SMat__.html#a3b183f6027e4dd11375d990fb8d7f008">setIdentity</a> ()</td></tr>
<tr class="memdesc:a3b183f6027e4dd11375d990fb8d7f008"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set equal to the unit matrix.  <a href="classmolpro_1_1SMat__.html#a3b183f6027e4dd11375d990fb8d7f008">More...</a><br /></td></tr>
<tr class="separator:a3b183f6027e4dd11375d990fb8d7f008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a2f0729c8d277b56aac40f0fc9801d8"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1SMat__.html#a2a2f0729c8d277b56aac40f0fc9801d8">str</a> (std::string title, int level=0, int precision=Eigen::StreamPrecision) const</td></tr>
<tr class="memdesc:a2a2f0729c8d277b56aac40f0fc9801d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a printable summary of the object.  <a href="classmolpro_1_1SMat__.html#a2a2f0729c8d277b56aac40f0fc9801d8">More...</a><br /></td></tr>
<tr class="separator:a2a2f0729c8d277b56aac40f0fc9801d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af00df9fde8fd27b222612b604cec0aaf"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1SMat__.html#af00df9fde8fd27b222612b604cec0aaf">str</a> (int verbosity=0, unsigned int columns=UINT_MAX) const</td></tr>
<tr class="separator:af00df9fde8fd27b222612b604cec0aaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0403579ec286fa82bba55b4dc50249c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1SMat__.html#aa0403579ec286fa82bba55b4dc50249c">scal</a> (<a class="el" href="classmolpro_1_1SMat__.html#a0b0793833395ba3be28166f1d3921341">value_type</a> a, bool scaleDiagonal=true)</td></tr>
<tr class="memdesc:aa0403579ec286fa82bba55b4dc50249c"><td class="mdescLeft">&#160;</td><td class="mdescRight">scal: Scale a matrix by a constant  <a href="classmolpro_1_1SMat__.html#aa0403579ec286fa82bba55b4dc50249c">More...</a><br /></td></tr>
<tr class="separator:aa0403579ec286fa82bba55b4dc50249c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a847253cb6a578d49a64612400309bd67"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1SMat__.html#a847253cb6a578d49a64612400309bd67">fill</a> (<a class="el" href="classmolpro_1_1SMat__.html#a0b0793833395ba3be28166f1d3921341">value_type</a> a)</td></tr>
<tr class="memdesc:a847253cb6a578d49a64612400309bd67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign a single scalar value to all elements of the matrix.  <a href="classmolpro_1_1SMat__.html#a847253cb6a578d49a64612400309bd67">More...</a><br /></td></tr>
<tr class="separator:a847253cb6a578d49a64612400309bd67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac795c5a262fae4bee4edaa94a71cf55e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1SMat__.html#ac795c5a262fae4bee4edaa94a71cf55e">axpy</a> (<a class="el" href="classmolpro_1_1SMat__.html#a0b0793833395ba3be28166f1d3921341">value_type</a> a, const <a class="el" href="classmolpro_1_1SMat__.html">SMat_</a> &amp;x)</td></tr>
<tr class="memdesc:ac795c5a262fae4bee4edaa94a71cf55e"><td class="mdescLeft">&#160;</td><td class="mdescRight">axpy Constant times a matrix plus a matrix, y=y+a*x  <a href="classmolpro_1_1SMat__.html#ac795c5a262fae4bee4edaa94a71cf55e">More...</a><br /></td></tr>
<tr class="separator:ac795c5a262fae4bee4edaa94a71cf55e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a572642adea5faac95ffde6488280dc3c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmolpro_1_1SMat__.html">SMat_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1SMat__.html#a572642adea5faac95ffde6488280dc3c">transform</a> (const <a class="el" href="classmolpro_1_1SMat__.html">SMat_</a> &amp;q, bool orthogonal=true) const</td></tr>
<tr class="memdesc:a572642adea5faac95ffde6488280dc3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a similarity transformation.  <a href="classmolpro_1_1SMat__.html#a572642adea5faac95ffde6488280dc3c">More...</a><br /></td></tr>
<tr class="separator:a572642adea5faac95ffde6488280dc3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37d11915f8ea6ad10c476ec3370d1d33"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmolpro_1_1SMat__.html">SMat_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1SMat__.html#a37d11915f8ea6ad10c476ec3370d1d33">diagonal</a> () const</td></tr>
<tr class="separator:a37d11915f8ea6ad10c476ec3370d1d33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cdd0f1342f2969068b4ea38188a8906"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1SMat__.html#a2cdd0f1342f2969068b4ea38188a8906">ev</a> (<a class="el" href="classmolpro_1_1SMat__.html">SMat_</a> &amp;val, <a class="el" href="classmolpro_1_1SMat__.html">SMat_</a> *vec=nullptr, <a class="el" href="classmolpro_1_1SMat__.html">SMat_</a> *vali=nullptr, <a class="el" href="classmolpro_1_1SMat__.html">SMat_</a> *vecl=nullptr, std::string algorithm=&quot;lapack&quot;, std::string sort=&quot;ascending&quot;) const</td></tr>
<tr class="separator:a2cdd0f1342f2969068b4ea38188a8906"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02a41573d916efcca2e28475ce243b01"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1SMat__.html#a02a41573d916efcca2e28475ce243b01">orthogonalize</a> (const <a class="el" href="classmolpro_1_1SMat__.html">SMat_</a> *metric=nullptr, std::string algorithm=&quot;Gram-Schmidt&quot;)</td></tr>
<tr class="memdesc:a02a41573d916efcca2e28475ce243b01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Orthonormalize the columns of the matrix.  <a href="classmolpro_1_1SMat__.html#a02a41573d916efcca2e28475ce243b01">More...</a><br /></td></tr>
<tr class="separator:a02a41573d916efcca2e28475ce243b01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b3a87a915e32f5ed1adf37c5ad117dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmolpro_1_1SMat__.html">SMat_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1SMat__.html#a6b3a87a915e32f5ed1adf37c5ad117dd">exp</a> () const</td></tr>
<tr class="memdesc:a6b3a87a915e32f5ed1adf37c5ad117dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the exponential of a matrix.  <a href="classmolpro_1_1SMat__.html#a6b3a87a915e32f5ed1adf37c5ad117dd">More...</a><br /></td></tr>
<tr class="separator:a6b3a87a915e32f5ed1adf37c5ad117dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a503cdf456709343ea17fc813454caddf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmolpro_1_1SMat__.html">SMat_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1SMat__.html#a503cdf456709343ea17fc813454caddf">log</a> () const</td></tr>
<tr class="memdesc:a503cdf456709343ea17fc813454caddf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the logarithm of a matrix.  <a href="classmolpro_1_1SMat__.html#a503cdf456709343ea17fc813454caddf">More...</a><br /></td></tr>
<tr class="separator:a503cdf456709343ea17fc813454caddf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f86776d92d5cf9667606b39525f9d40"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmolpro_1_1SMat__.html">SMat_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1SMat__.html#a0f86776d92d5cf9667606b39525f9d40">sqrt</a> () const</td></tr>
<tr class="memdesc:a0f86776d92d5cf9667606b39525f9d40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the square root of a matrix.  <a href="classmolpro_1_1SMat__.html#a0f86776d92d5cf9667606b39525f9d40">More...</a><br /></td></tr>
<tr class="separator:a0f86776d92d5cf9667606b39525f9d40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac352224d7a7d8b5643b51c497cef187b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmolpro_1_1SMat__.html">SMat_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1SMat__.html#ac352224d7a7d8b5643b51c497cef187b">pow</a> (<a class="el" href="classmolpro_1_1SMat__.html#a0b0793833395ba3be28166f1d3921341">value_type</a> p) const</td></tr>
<tr class="memdesc:ac352224d7a7d8b5643b51c497cef187b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate a power of a matrix.  <a href="classmolpro_1_1SMat__.html#ac352224d7a7d8b5643b51c497cef187b">More...</a><br /></td></tr>
<tr class="separator:ac352224d7a7d8b5643b51c497cef187b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e7dfbc96ba45996acb36ba60efdda5e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmolpro_1_1SMat__.html">SMat_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1SMat__.html#a4e7dfbc96ba45996acb36ba60efdda5e">inverse</a> (<a class="el" href="classmolpro_1_1SMat__.html#a8b8c1114d47d84f7d7ed2924fe11ed23">scalar_type</a> SVThresh=0.0) const</td></tr>
<tr class="memdesc:a4e7dfbc96ba45996acb36ba60efdda5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the inverse of a matrix.  <a href="classmolpro_1_1SMat__.html#a4e7dfbc96ba45996acb36ba60efdda5e">More...</a><br /></td></tr>
<tr class="separator:a4e7dfbc96ba45996acb36ba60efdda5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeced17693b785a25d29c67350865961"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmolpro_1_1SMat__.html">SMat_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1SMat__.html#aaeced17693b785a25d29c67350865961">solve</a> (const <a class="el" href="classmolpro_1_1SMat__.html">SMat_</a> &amp;rhs, std::string algorithm=&quot;ColPivHouseholderQR&quot;) const</td></tr>
<tr class="memdesc:aaeced17693b785a25d29c67350865961"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve one or more linear equation systems, where the current matrix is the coefficient matrix.  <a href="classmolpro_1_1SMat__.html#aaeced17693b785a25d29c67350865961">More...</a><br /></td></tr>
<tr class="separator:aaeced17693b785a25d29c67350865961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a634e0ddc74bc09838dde93545085661f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmolpro_1_1SMat__.html">SMat_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1SMat__.html#a634e0ddc74bc09838dde93545085661f">desymmetrise</a> () const</td></tr>
<tr class="memdesc:a634e0ddc74bc09838dde93545085661f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Produce a copy of the object which has no symmetry.  <a href="classmolpro_1_1SMat__.html#a634e0ddc74bc09838dde93545085661f">More...</a><br /></td></tr>
<tr class="separator:a634e0ddc74bc09838dde93545085661f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a957ab00af39f9506b9115df9cfacc561"><td class="memItemLeft" align="right" valign="top">class molpro::bytestream&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1SMat__.html#a957ab00af39f9506b9115df9cfacc561">bytestream</a> (bool <a class="el" href="classmolpro_1_1SMat__.html#a54ad673f1ae269ec9777255219d74d20">data</a>=true)</td></tr>
<tr class="memdesc:a957ab00af39f9506b9115df9cfacc561"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialise the object to a stream of bytes.  <a href="classmolpro_1_1SMat__.html#a957ab00af39f9506b9115df9cfacc561">More...</a><br /></td></tr>
<tr class="separator:a957ab00af39f9506b9115df9cfacc561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9ce68b6801a554e81f4408409bd737f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1SMat__.html#ae9ce68b6801a554e81f4408409bd737f">axpy</a> (<a class="el" href="classmolpro_1_1SMat__.html#a0b0793833395ba3be28166f1d3921341">value_type</a> a, const std::map&lt; size_t, <a class="el" href="classmolpro_1_1SMat__.html#a0b0793833395ba3be28166f1d3921341">value_type</a> &gt; &amp;other)</td></tr>
<tr class="separator:ae9ce68b6801a554e81f4408409bd737f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ba0ca2bd576b95d256041c67aecfb74"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmolpro_1_1SMat__.html#a8b8c1114d47d84f7d7ed2924fe11ed23">scalar_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1SMat__.html#a5ba0ca2bd576b95d256041c67aecfb74">dot</a> (const <a class="el" href="classmolpro_1_1SMat__.html">SMat_</a> &amp;other) const</td></tr>
<tr class="separator:a5ba0ca2bd576b95d256041c67aecfb74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a672d4f2699a86d74f2298ffaaa1ad28c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmolpro_1_1SMat__.html#a8b8c1114d47d84f7d7ed2924fe11ed23">scalar_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1SMat__.html#a672d4f2699a86d74f2298ffaaa1ad28c">dot</a> (const std::map&lt; size_t, <a class="el" href="classmolpro_1_1SMat__.html#a0b0793833395ba3be28166f1d3921341">value_type</a> &gt; &amp;other) const</td></tr>
<tr class="separator:a672d4f2699a86d74f2298ffaaa1ad28c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf2c94dde6a37469cfd6787c9921ab89"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; std::vector&lt; size_t &gt;, std::vector&lt; <a class="el" href="classmolpro_1_1SMat__.html#a0b0793833395ba3be28166f1d3921341">value_type</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1SMat__.html#acf2c94dde6a37469cfd6787c9921ab89">select</a> (const molpro::array&lt; <a class="el" href="classmolpro_1_1SMat__.html#a0b0793833395ba3be28166f1d3921341">value_type</a> &gt; &amp;measure, const size_t maximumNumber=1000, const <a class="el" href="classmolpro_1_1SMat__.html#a8b8c1114d47d84f7d7ed2924fe11ed23">scalar_type</a> threshold=0) const</td></tr>
<tr class="separator:acf2c94dde6a37469cfd6787c9921ab89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6beb9b03aa3126b8d2ebe6c4a0a8bee1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1SMat__.html#a6beb9b03aa3126b8d2ebe6c4a0a8bee1">ev</a> (<a class="el" href="classmolpro_1_1SMat__.html">SMat_</a>&lt; double &gt; &amp;val, <a class="el" href="classmolpro_1_1SMat__.html">SMat_</a>&lt; double &gt; *vec, <a class="el" href="classmolpro_1_1SMat__.html">SMat_</a>&lt; double &gt; *vali, <a class="el" href="classmolpro_1_1SMat__.html">SMat_</a>&lt; double &gt; *vecl, std::string algorithm, std::string sort) const</td></tr>
<tr class="separator:a6beb9b03aa3126b8d2ebe6c4a0a8bee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac569d073f21357ef567ef5117a0277f"><td class="memItemLeft" align="right" valign="top">molpro::bytestream&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1SMat__.html#aac569d073f21357ef567ef5117a0277f">bytestream</a> (bool <a class="el" href="classmolpro_1_1SMat__.html#a54ad673f1ae269ec9777255219d74d20">data</a>)</td></tr>
<tr class="separator:aac569d073f21357ef567ef5117a0277f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31e6c8494b6db22c4e2ed74b4dc376c2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1SMat__.html#a31e6c8494b6db22c4e2ed74b4dc376c2">SMat_</a> (const char *dump, double *buffer)</td></tr>
<tr class="separator:a31e6c8494b6db22c4e2ed74b4dc376c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a40c0103547dd73b67fe34b59e58c6bc8"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1SMat__.html#a40c0103547dd73b67fe34b59e58c6bc8">m_description</a></td></tr>
<tr class="memdesc:a40c0103547dd73b67fe34b59e58c6bc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">A string describing the object.  <a href="classmolpro_1_1SMat__.html#a40c0103547dd73b67fe34b59e58c6bc8">More...</a><br /></td></tr>
<tr class="separator:a40c0103547dd73b67fe34b59e58c6bc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class T&gt;<br />
class molpro::SMat_&lt; T &gt;</h3>

<p>The SMat class holds the meta-information and a pointer to data for a symmetry-packed matrix object. The <a class="el" href="namespacemolpro.html#ad80f79742f183b105c60b295863d6718">SMat</a> is characterised by the symmetry, parity, and rank of the matrix, and its row and column dimensions in each symmetry. </p>
<p>Internally, the data are stored in a molpro::array&lt;T&gt; with exactly the same layout as Molpro's symmetry-packed matrices. There are facilities to construct an <a class="el" href="namespacemolpro.html#ad80f79742f183b105c60b295863d6718">SMat</a> attached to an existing data buffer, and to return a pointer to the buffer, to allow interoperability with legacy code. The intended normal usage mode is either (and preferably) via the high-level functions and operators provided with the class, or using the symmetry blocks provided by <a class="el" href="classmolpro_1_1SMat__.html#ac645aaea1fb648500512ab87e7a727a6">block()</a>.</p>
<p>Ranks 0 (vector) and 1 (matrix) are supported. In the case of matrices, the class stores a notion of whether the matrix is to be used transposed or not; this allows transposition of the matrix without moving data. In addition, in the case of symmetric or antisymmetric matrices, redundant symmetry blocks are not stored, and if they are requested, the transpose block will be returned. Therefore all code that accesses symmetry blocks via <a class="el" href="classmolpro_1_1SMat__.html#ac645aaea1fb648500512ab87e7a727a6">block()</a> must enquire via <a class="el" href="classmolpro_1_1SMat__.html#ab2bff361bef7e21e8d5559c84f1149e5">block_transposed()</a> or <a class="el" href="classmolpro_1_1SMat__.html#ab93b3f5593b33760619295753b5d59d5">block_dimensions()</a> whether the block is transposed or not.</p>
<p>Example: </p><div class="fragment"><div class="line"> <a class="code" href="namespacemolpro.html#a67177c2ad49feab84008cc04c3bb1f7c">dim_t</a> dim; dim.push_back(3); dim.push_back(2);</div>
<div class="line"> <a class="code" href="namespacemolpro.html#a7a136b7a21c942e40967ed5bab20ff2e">dims_t</a> dims; dims.push_back(dim); dims.push_back(dim); <span class="comment">// dimensions of a 3*3 + 2*2 matrix (if symmetry=0)</span></div>
<div class="line"> SMat_&lt;double&gt; m(dims,-1,1); <span class="comment">// antisymmetric matrix of symmetry 1</span></div>
<div class="line"> std::cout &lt;&lt; m.block_transposed(0) &lt;&lt;<span class="stringliteral">&quot;,&quot;</span>&lt;&lt;m.block_transposed(1)&lt;&lt;std::endl; <span class="comment">// returns 1,0 because only blocks with</span></div>
<div class="line">sym(row) &gt; sym(col) are actually stored. std::cout &lt;&lt; <span class="stringliteral">&quot;Matrix symmetry=&quot;</span>&lt;&lt;m.symmetry()&lt;&lt;<span class="stringliteral">&quot;; matrix</span></div>
<div class="line"><span class="stringliteral">parity=&quot;</span>&lt;&lt;m.parity()&lt;&lt;std::endl; std::cout &lt;&lt; <span class="stringliteral">&quot;block.dimensions(0): &quot;</span>&lt;&lt;m.block_dimensions(0)[0] &lt;&lt;</div>
<div class="line">m.block_dimensions(0)[1] &lt;&lt; m.block_dimensions(0)[2] &lt;&lt; std::endl; std::cout &lt;&lt; <span class="stringliteral">&quot;block.dimensions(1):</span></div>
<div class="line"><span class="stringliteral">&quot;</span>&lt;&lt;m.block_dimensions(1)[0] &lt;&lt; m.block_dimensions(1)[1] &lt;&lt; m.block_dimensions(1)[2] &lt;&lt; std::endl; <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> k=0;</div>
<div class="line">k&lt;m.block(1).<a class="code" href="classmolpro_1_1SMat__.html#a991324ba20fa8d9dfedd0e39570e7d5e">size</a>(); k++) m.block(1)[k]=k+100.0; <span class="comment">// some data for (unsigned int sym=0; sym&lt;8; sym++) { size_t</span></div>
<div class="line">rowstride=m.block_transposed(sym)?m.dimension(sym^m.symmetry(),1):1; <span class="keywordtype">size_t</span></div>
<div class="line">colstride=m.block_transposed(sym)?1:m.dimension(sym,0); <span class="keywordtype">double</span> factor=m.block_transposed(sym)?m.parity():1; <span class="keywordflow">for</span></div>
<div class="line">(<span class="keywordtype">size_t</span> row=0; row&lt;m.dimension(sym,0);row++) { <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> col=0; col&lt;m.dimension(sym^m.symmetry(),1);col++)</div>
<div class="line">             std::cout &lt;&lt;</div>
<div class="line"><span class="stringliteral">&quot;m(&quot;</span>&lt;&lt;row&lt;&lt;<span class="stringliteral">&quot;.&quot;</span>&lt;&lt;sym&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>&lt;&lt;col&lt;&lt;<span class="stringliteral">&quot;.&quot;</span>&lt;&lt;(sym^m.symmetry())&lt;&lt;<span class="stringliteral">&quot;)=&quot;</span>&lt;&lt;factor*(m.block(sym)[col*colstride+row*rowstride])&lt;&lt;<span class="stringliteral">&quot;;</span></div>
<div class="line"><span class="stringliteral">&quot;</span>; std::cout &lt;&lt; std::endl;</div>
<div class="line">     }</div>
<div class="line"> }</div>
<div class="ttc" id="aclassmolpro_1_1SMat___html_a991324ba20fa8d9dfedd0e39570e7d5e"><div class="ttname"><a href="classmolpro_1_1SMat__.html#a991324ba20fa8d9dfedd0e39570e7d5e">molpro::SMat_::size</a></div><div class="ttdeci">size_t size() const</div><div class="ttdoc">Return the buffer size of an SMat object.</div><div class="ttdef"><b>Definition:</b> SMat-implementation.h:398</div></div>
<div class="ttc" id="anamespacemolpro_html_a67177c2ad49feab84008cc04c3bb1f7c"><div class="ttname"><a href="namespacemolpro.html#a67177c2ad49feab84008cc04c3bb1f7c">molpro::dim_t</a></div><div class="ttdeci">std::vector&lt; size_t &gt; dim_t</div><div class="ttdoc">Dimension for each symmetry in one axis of an SMat.</div><div class="ttdef"><b>Definition:</b> SMat.h:21</div></div>
<div class="ttc" id="anamespacemolpro_html_a7a136b7a21c942e40967ed5bab20ff2e"><div class="ttname"><a href="namespacemolpro.html#a7a136b7a21c942e40967ed5bab20ff2e">molpro::dims_t</a></div><div class="ttdeci">std::vector&lt; dim_t &gt; dims_t</div><div class="ttdoc">dims_t Dimensions for an entire SMat</div><div class="ttdef"><b>Definition:</b> SMat.h:25</div></div>
</div><!-- fragment --> <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>data type of contained matrix elements </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a0327b4b21be7f823b70447284ececf11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0327b4b21be7f823b70447284ececf11">&#9670;&nbsp;</a></span>M</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Eigen::Map&lt;Eigen::Matrix&lt;<a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a>, Eigen::Dynamic, Eigen::Dynamic&gt;, Eigen::Unaligned, Eigen::Stride&lt;Eigen::Dynamic, Eigen::Dynamic&gt; &gt; <a class="el" href="classmolpro_1_1SMat__.html">molpro::SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt;::<a class="el" href="classmolpro_1_1SMat__.html#a0327b4b21be7f823b70447284ececf11">M</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ace72697d7f93c836aa30a2adcdac5f81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace72697d7f93c836aa30a2adcdac5f81">&#9670;&nbsp;</a></span>Mconst</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Eigen::Map&lt;const Eigen::Matrix&lt;<a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a>, Eigen::Dynamic, Eigen::Dynamic&gt;, Eigen::Unaligned, Eigen::Stride&lt;Eigen::Dynamic, Eigen::Dynamic&gt; &gt; <a class="el" href="classmolpro_1_1SMat__.html">molpro::SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt;::<a class="el" href="classmolpro_1_1SMat__.html#ace72697d7f93c836aa30a2adcdac5f81">Mconst</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8b8c1114d47d84f7d7ed2924fe11ed23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b8c1114d47d84f7d7ed2924fe11ed23">&#9670;&nbsp;</a></span>scalar_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmolpro_1_1SMat__.html">molpro::SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt;::<a class="el" href="classmolpro_1_1SMat__.html#a8b8c1114d47d84f7d7ed2924fe11ed23">scalar_type</a> =  <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abbe220caa385afb70fd47bcbe2be0487"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbe220caa385afb70fd47bcbe2be0487">&#9670;&nbsp;</a></span>V</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Eigen::Map&lt;Eigen::Matrix&lt;<a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a>, Eigen::Dynamic, 1&gt; &gt; <a class="el" href="classmolpro_1_1SMat__.html">molpro::SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt;::<a class="el" href="classmolpro_1_1SMat__.html#abbe220caa385afb70fd47bcbe2be0487">V</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0b0793833395ba3be28166f1d3921341"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b0793833395ba3be28166f1d3921341">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmolpro_1_1SMat__.html">molpro::SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt;::<a class="el" href="classmolpro_1_1SMat__.html#a0b0793833395ba3be28166f1d3921341">value_type</a> =  <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="af808f2a29da585e8ebc8dae3ca31c3b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af808f2a29da585e8ebc8dae3ca31c3b0">&#9670;&nbsp;</a></span>SMat_() <span class="overload">[1/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmolpro_1_1SMat__.html">molpro::SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt;::<a class="el" href="classmolpro_1_1SMat__.html">SMat_</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemolpro.html#a7a136b7a21c942e40967ed5bab20ff2e">dims_t</a>&#160;</td>
          <td class="paramname"><em>dimensions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemolpro.html#a77b8d977180296c55c184036b65c5a6f">parity_t</a>&#160;</td>
          <td class="paramname"><em>parity</em> = <code><a class="el" href="namespacemolpro.html#a77b8d977180296c55c184036b65c5a6fab84d144528f1a54d906ec2d9922f3aec">parityNone</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>symmetry</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>diagonal</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>description</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct using explicit symmetry-block dimensions. The data buffer is allocated and maintained internally. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dimensions</td><td>Numbers of rows and columns in each symmetry block. dimensions.size() indicates the desired rank (1 or 2). </td></tr>
    <tr><td class="paramname">parity</td><td>Index permutation symmetry: 0=none, 1=symmetric, -1=antisymmetric, default 0. </td></tr>
    <tr><td class="paramname">symmetry</td><td>Overall symmetry of matrix (0-7). </td></tr>
    <tr><td class="paramname">diagonal</td><td>Whether this is a diagonal matrix </td></tr>
    <tr><td class="paramname">description</td><td>A string describing the object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a14857bfc39552244d6778a125f5ecdcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14857bfc39552244d6778a125f5ecdcd">&#9670;&nbsp;</a></span>SMat_() <span class="overload">[2/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmolpro_1_1SMat__.html">molpro::SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt;::<a class="el" href="classmolpro_1_1SMat__.html">SMat_</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemolpro.html#a7a136b7a21c942e40967ed5bab20ff2e">dims_t</a>&#160;</td>
          <td class="paramname"><em>dimensions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">molpro::array&lt; <a class="el" href="classmolpro_1_1SMat__.html#a0b0793833395ba3be28166f1d3921341">value_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemolpro.html#a77b8d977180296c55c184036b65c5a6f">parity_t</a>&#160;</td>
          <td class="paramname"><em>parity</em> = <code><a class="el" href="namespacemolpro.html#a77b8d977180296c55c184036b65c5a6fab84d144528f1a54d906ec2d9922f3aec">parityNone</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>symmetry</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>diagonal</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>description</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct using explicit symmetry-block dimensions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>A pointer to an existing buffer of the right size, which this object will attach to, instead of creating its own buffer.</td></tr>
    <tr><td class="paramname">dimensions</td><td>Numbers of rows and columns in each symmetry block. dimensions.size() indicates the desired rank (1 or 2).</td></tr>
    <tr><td class="paramname">parity</td><td>Index permutation symmetry: 0=none, 1=symmetric, -1=antisymmetric, default 0.</td></tr>
    <tr><td class="paramname">symmetry</td><td>Overall symmetry of matrix (0-7).</td></tr>
    <tr><td class="paramname">diagonal</td><td>Whether this is a diagonal matrix</td></tr>
    <tr><td class="paramname">description</td><td>A string describing the object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adcc071139db4f4cb5d9aff40cc816e4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcc071139db4f4cb5d9aff40cc816e4f">&#9670;&nbsp;</a></span>SMat_() <span class="overload">[3/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmolpro_1_1SMat__.html">molpro::SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt;::<a class="el" href="classmolpro_1_1SMat__.html">SMat_</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemolpro.html#a7a136b7a21c942e40967ed5bab20ff2e">dims_t</a>&#160;</td>
          <td class="paramname"><em>dimensions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmolpro_1_1SMat__.html#a0b0793833395ba3be28166f1d3921341">value_type</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemolpro.html#a77b8d977180296c55c184036b65c5a6f">parity_t</a>&#160;</td>
          <td class="paramname"><em>parity</em> = <code><a class="el" href="namespacemolpro.html#a77b8d977180296c55c184036b65c5a6fab84d144528f1a54d906ec2d9922f3aec">parityNone</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>symmetry</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>diagonal</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>description</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct using explicit symmetry-block dimensions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>A pointer to an existing buffer of the right size, which this object will attach to, instead of creating its own buffer.</td></tr>
    <tr><td class="paramname">dimensions</td><td>Numbers of rows and columns in each symmetry block. dimensions.size() indicates the desired rank (1 or 2).</td></tr>
    <tr><td class="paramname">parity</td><td>Index permutation symmetry: 0=none, 1=symmetric, -1=antisymmetric, default 0.</td></tr>
    <tr><td class="paramname">symmetry</td><td>Overall symmetry of matrix (0-7).</td></tr>
    <tr><td class="paramname">diagonal</td><td>Whether this is a diagonal matrix</td></tr>
    <tr><td class="paramname">description</td><td>A string describing the object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad75df24c8852f5384bf3e61fcbc0c1f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad75df24c8852f5384bf3e61fcbc0c1f6">&#9670;&nbsp;</a></span>SMat_() <span class="overload">[4/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmolpro_1_1SMat__.html">molpro::SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt;::<a class="el" href="classmolpro_1_1SMat__.html">SMat_</a> </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemolpro.html#a77b8d977180296c55c184036b65c5a6f">molpro::parity_t</a>&#160;</td>
          <td class="paramname"><em>parity</em> = <code><a class="el" href="namespacemolpro.html#a77b8d977180296c55c184036b65c5a6fab84d144528f1a54d906ec2d9922f3aec">parityNone</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>symmetry</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>diagonal</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>description</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct using symmetry-block dimensions obtained from standard orbital space definitions. The data buffer is allocated and maintained internally. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">space</td><td>Designator of which orbital space ('X', 'Y', 'Z' or blank (default)). Two characters can be given to indicate a rank-2 matrix with possibly different spaces for rows and columns, e.g. 'XY'.</td></tr>
    <tr><td class="paramname">symmetry</td><td>Overall symmetry of matrix (0-7).</td></tr>
    <tr><td class="paramname">parity</td><td>Index permutation symmetry: 0=none, 1=symmetric, -1=antisymmetric, default 0.</td></tr>
    <tr><td class="paramname">diagonal</td><td>Whether this is a diagonal matrix</td></tr>
    <tr><td class="paramname">description</td><td>A string describing the object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a64bd7f74bbc04f1c3ab4f4f900fe86cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64bd7f74bbc04f1c3ab4f4f900fe86cd">&#9670;&nbsp;</a></span>SMat_() <span class="overload">[5/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmolpro_1_1SMat__.html">molpro::SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt;::<a class="el" href="classmolpro_1_1SMat__.html">SMat_</a> </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">molpro::array&lt; <a class="el" href="classmolpro_1_1SMat__.html#a0b0793833395ba3be28166f1d3921341">value_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemolpro.html#a77b8d977180296c55c184036b65c5a6f">molpro::parity_t</a>&#160;</td>
          <td class="paramname"><em>parity</em> = <code><a class="el" href="namespacemolpro.html#a77b8d977180296c55c184036b65c5a6fab84d144528f1a54d906ec2d9922f3aec">parityNone</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>symmetry</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>diagonal</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>description</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct using symmetry-block dimensions obtained from standard orbital space definitions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">space</td><td>Designator of which orbital space ('X', 'Y', 'Z' or blank (default)). </td></tr>
    <tr><td class="paramname">buffer</td><td>A pointer to an existing buffer of the right size, which this object will attach to, instead of creating its own buffer. Two characters can be given to indicate a rank-2 matrix with possibly different spaces for rows and columns, e.g. 'XY'.</td></tr>
    <tr><td class="paramname">symmetry</td><td>Overall symmetry of matrix (0-7).</td></tr>
    <tr><td class="paramname">parity</td><td>Index permutation symmetry: 0=none, 1=symmetric, -1=antisymmetric, default 0.</td></tr>
    <tr><td class="paramname">diagonal</td><td>Whether this is a diagonal matrix </td></tr>
    <tr><td class="paramname">description</td><td>A string describing the object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a39e4d9da3065b19a3c0d8b9ae98ed3c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39e4d9da3065b19a3c0d8b9ae98ed3c3">&#9670;&nbsp;</a></span>SMat_() <span class="overload">[6/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmolpro_1_1SMat__.html">molpro::SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt;::<a class="el" href="classmolpro_1_1SMat__.html">SMat_</a> </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmolpro_1_1SMat__.html#a0b0793833395ba3be28166f1d3921341">value_type</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemolpro.html#a77b8d977180296c55c184036b65c5a6f">molpro::parity_t</a>&#160;</td>
          <td class="paramname"><em>parity</em> = <code><a class="el" href="namespacemolpro.html#a77b8d977180296c55c184036b65c5a6fab84d144528f1a54d906ec2d9922f3aec">parityNone</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>symmetry</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>diagonal</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>description</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct using symmetry-block dimensions obtained from standard orbital space definitions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">space</td><td>Designator of which orbital space ('X', 'Y', 'Z' or blank (default)). </td></tr>
    <tr><td class="paramname">buffer</td><td>A pointer to an existing buffer of the right size, which this object will attach to, instead of creating its own buffer. Two characters can be given to indicate a rank-2 matrix with possibly different spaces for rows and columns, e.g. 'XY'.</td></tr>
    <tr><td class="paramname">symmetry</td><td>Overall symmetry of matrix (0-7).</td></tr>
    <tr><td class="paramname">parity</td><td>Index permutation symmetry: 0=none, 1=symmetric, -1=antisymmetric, default 0.</td></tr>
    <tr><td class="paramname">description</td><td>A string describing the object. </td></tr>
    <tr><td class="paramname">diagonal</td><td>Whether this is a diagonal matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af2cc7af6ba16f310f745724129d5c932"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2cc7af6ba16f310f745724129d5c932">&#9670;&nbsp;</a></span>SMat_() <span class="overload">[7/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmolpro_1_1SMat__.html">molpro::SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt;::<a class="el" href="classmolpro_1_1SMat__.html">SMat_</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmolpro_1_1SMat__.html">SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt; const *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemolpro.html#a77b8d977180296c55c184036b65c5a6f">parity_t</a>&#160;</td>
          <td class="paramname"><em>parity</em> = <code><a class="el" href="namespacemolpro.html#a77b8d977180296c55c184036b65c5a6fa36d4c7d8181c3d6fc1f1519c27b6e543">parityUnspecified</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>symmetry</em> = <code>9</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>rank</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>diagonal</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>description</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct <a class="el" href="namespacemolpro.html#ad80f79742f183b105c60b295863d6718">SMat</a> templated by another <a class="el" href="namespacemolpro.html#ad80f79742f183b105c60b295863d6718">SMat</a>. The actual data are not copied. The new data buffer is allocated and maintained internally. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>the <a class="el" href="namespacemolpro.html#ad80f79742f183b105c60b295863d6718">SMat</a> to copy. </td></tr>
    <tr><td class="paramname">symmetry</td><td>Overall symmetry of matrix (0-7). If not given, <code>source.symmetry</code> is used </td></tr>
    <tr><td class="paramname">parity</td><td>Index permutation symmetry: 0=none, 1=symmetric, -1=antisymmetric. If not given, <code>source.parity</code> is used.</td></tr>
    <tr><td class="paramname">rank</td><td>1=vector, 2=matrix, 3=matrix that is transpose of source. If not given, <code>source.rank</code> is used. </td></tr>
    <tr><td class="paramname">diagonal</td><td>Whether this is a diagonal matrix </td></tr>
    <tr><td class="paramname">description</td><td>A string describing the object. Defaults to source-&gt;m_description. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa1ee4ed1ddc82c615d84b96af006f99c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1ee4ed1ddc82c615d84b96af006f99c">&#9670;&nbsp;</a></span>SMat_() <span class="overload">[8/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmolpro_1_1SMat__.html">molpro::SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt;::<a class="el" href="classmolpro_1_1SMat__.html">SMat_</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmolpro_1_1SMat__.html">SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt; const *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">molpro::array&lt; <a class="el" href="classmolpro_1_1SMat__.html#a0b0793833395ba3be28166f1d3921341">value_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemolpro.html#a77b8d977180296c55c184036b65c5a6f">parity_t</a>&#160;</td>
          <td class="paramname"><em>parity</em> = <code><a class="el" href="namespacemolpro.html#a77b8d977180296c55c184036b65c5a6fa36d4c7d8181c3d6fc1f1519c27b6e543">parityUnspecified</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>symmetry</em> = <code>9</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>rank</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>diagonal</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>description</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct <a class="el" href="namespacemolpro.html#ad80f79742f183b105c60b295863d6718">SMat</a> templated by another <a class="el" href="namespacemolpro.html#ad80f79742f183b105c60b295863d6718">SMat</a>. The actual data are not copied. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>the <a class="el" href="namespacemolpro.html#ad80f79742f183b105c60b295863d6718">SMat</a> to copy. </td></tr>
    <tr><td class="paramname">buffer</td><td>A pointer to an existing buffer of the right size, which this object will attach to, instead of creating its own buffer.</td></tr>
    <tr><td class="paramname">symmetry</td><td>Overall symmetry of matrix (0-7). If not given, <code>source.symmetry</code> is used </td></tr>
    <tr><td class="paramname">parity</td><td>Index permutation symmetry: 0=none, 1=symmetric, -1=antisymmetric. If not given, <code>source.parity</code> is used.</td></tr>
    <tr><td class="paramname">rank</td><td>1=vector, 2=matrix, 3=matrix that is transpose of source. If not given, <code>source.rank</code> is used. </td></tr>
    <tr><td class="paramname">diagonal</td><td>Whether this is a diagonal matrix </td></tr>
    <tr><td class="paramname">description</td><td>A string describing the object. Defaults to source-&gt;m_description. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a82319192daa2d0194d4c8e6f56155632"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82319192daa2d0194d4c8e6f56155632">&#9670;&nbsp;</a></span>SMat_() <span class="overload">[9/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmolpro_1_1SMat__.html">molpro::SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt;::<a class="el" href="classmolpro_1_1SMat__.html">SMat_</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmolpro_1_1SMat__.html">SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt; const *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmolpro_1_1SMat__.html#a0b0793833395ba3be28166f1d3921341">value_type</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemolpro.html#a77b8d977180296c55c184036b65c5a6f">parity_t</a>&#160;</td>
          <td class="paramname"><em>parity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>symmetry</em> = <code>9</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>rank</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>diagonal</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>description</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct <a class="el" href="namespacemolpro.html#ad80f79742f183b105c60b295863d6718">SMat</a> templated by another <a class="el" href="namespacemolpro.html#ad80f79742f183b105c60b295863d6718">SMat</a>. The actual data are not copied. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>the <a class="el" href="namespacemolpro.html#ad80f79742f183b105c60b295863d6718">SMat</a> to copy. </td></tr>
    <tr><td class="paramname">buffer</td><td>A pointer to an existing buffer of the right size, which this object will attach to, instead of creating its own buffer.</td></tr>
    <tr><td class="paramname">symmetry</td><td>Overall symmetry of matrix (0-7). If not given, <code>source.symmetry</code> is used </td></tr>
    <tr><td class="paramname">parity</td><td>Index permutation symmetry: 0=none, 1=symmetric, -1=antisymmetric. If not given, <code>source.parity</code> is used.</td></tr>
    <tr><td class="paramname">rank</td><td>1=vector, 2=matrix, 3=matrix that is transpose of source. If not given, <code>source.rank</code> is used. </td></tr>
    <tr><td class="paramname">diagonal</td><td>Whether this is a diagonal matrix </td></tr>
    <tr><td class="paramname">description</td><td>A string describing the object. Defaults to source-&gt;description. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab99b3114ed6ddaeea1d471048aaf39ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab99b3114ed6ddaeea1d471048aaf39ca">&#9670;&nbsp;</a></span>SMat_() <span class="overload">[10/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmolpro_1_1SMat__.html">molpro::SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt;::<a class="el" href="classmolpro_1_1SMat__.html">SMat_</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmolpro_1_1SMat__.html">SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>option</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>from where to copy </td></tr>
    <tr><td class="paramname">option</td><td><ul>
<li>1: offline storage if possible</li>
<li>2: distributed storage if possible If offline or distributed storage is used, most of the class functions that access data cannot be used. The exceptions are axpy, dot, scal </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6a4f9846a6de8a97218b002256490d5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a4f9846a6de8a97218b002256490d5d">&#9670;&nbsp;</a></span>SMat_() <span class="overload">[11/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmolpro_1_1SMat__.html">molpro::SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt;::<a class="el" href="classmolpro_1_1SMat__.html">SMat_</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>dump</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmolpro_1_1SMat__.html#a0b0793833395ba3be28166f1d3921341">value_type</a> *&#160;</td>
          <td class="paramname"><em>buffer</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an object from what is produced by <a class="el" href="classmolpro_1_1SMat__.html#a957ab00af39f9506b9115df9cfacc561" title="Serialise the object to a stream of bytes.">bytestream()</a>. If the bytestream contains data, it will be loaded, otherwise the contents of the object are undefined, and only the dimensions and parameters are loaded. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dump</td><td>The raw buffer of a bytestream produced by <a class="el" href="classmolpro_1_1SMat__.html#a957ab00af39f9506b9115df9cfacc561" title="Serialise the object to a stream of bytes.">bytestream()</a> </td></tr>
    <tr><td class="paramname">buffer</td><td>Location of actual data. If provided, the new object will attach to this, otherwise a new buffer will be constructed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7ca0b0ca854905e53878e6be96c994dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ca0b0ca854905e53878e6be96c994dc">&#9670;&nbsp;</a></span>SMat_() <span class="overload">[12/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmolpro_1_1SMat__.html">molpro::SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt;::<a class="el" href="classmolpro_1_1SMat__.html">SMat_</a> </td>
          <td>(</td>
          <td class="paramtype">const molpro::bytestream &amp;&#160;</td>
          <td class="paramname"><em>bs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmolpro_1_1SMat__.html#a0b0793833395ba3be28166f1d3921341">value_type</a> *&#160;</td>
          <td class="paramname"><em>buffer</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an object from what is produced by <a class="el" href="classmolpro_1_1SMat__.html#a957ab00af39f9506b9115df9cfacc561" title="Serialise the object to a stream of bytes.">bytestream()</a>. If the bytestream contains data, it will be loaded, otherwise the contents of the object are undefined, and only the dimensions and parameters are loaded. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bs</td><td>The bytestream produced by <a class="el" href="classmolpro_1_1SMat__.html#a957ab00af39f9506b9115df9cfacc561" title="Serialise the object to a stream of bytes.">bytestream()</a> </td></tr>
    <tr><td class="paramname">buffer</td><td>Location of actual data. If provided, the new object will attach to this, otherwise a new buffer will be constructed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5df30e81a0c10dd11c3f3c1d525459fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5df30e81a0c10dd11c3f3c1d525459fa">&#9670;&nbsp;</a></span>~SMat_()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmolpro_1_1SMat__.html">molpro::SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt;::~<a class="el" href="classmolpro_1_1SMat__.html">SMat_</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a250d4fcd59dd037c272d272fa0a0ca07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a250d4fcd59dd037c272d272fa0a0ca07">&#9670;&nbsp;</a></span>SMat_() <span class="overload">[13/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmolpro_1_1SMat__.html">molpro::SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt;::<a class="el" href="classmolpro_1_1SMat__.html">SMat_</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construction of an empty <a class="el" href="namespacemolpro.html#ad80f79742f183b105c60b295863d6718">SMat</a> is allowed to support those clients that need it, but the result is not meaningfully usable. </p>

</div>
</div>
<a id="a1598222c5621f038a6f8260f149f1e68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1598222c5621f038a6f8260f149f1e68">&#9670;&nbsp;</a></span>SMat_() <span class="overload">[14/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmolpro_1_1SMat__.html">molpro::SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt;::<a class="el" href="classmolpro_1_1SMat__.html">SMat_</a> </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; size_t, <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a31e6c8494b6db22c4e2ed74b4dc376c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31e6c8494b6db22c4e2ed74b4dc376c2">&#9670;&nbsp;</a></span>SMat_() <span class="overload">[15/15]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmolpro_1_1SMat__.html">molpro::SMat_</a>&lt; double &gt;::<a class="el" href="classmolpro_1_1SMat__.html">SMat_</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>dump</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a79992ebc8adb0f55ccbfcae9298cf496"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79992ebc8adb0f55ccbfcae9298cf496">&#9670;&nbsp;</a></span>assign()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmolpro_1_1SMat__.html">molpro::SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt;::assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmolpro_1_1SMat__.html#a0b0793833395ba3be28166f1d3921341">value_type</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the elements of the matrix to a value. </p>

</div>
</div>
<a id="ac795c5a262fae4bee4edaa94a71cf55e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac795c5a262fae4bee4edaa94a71cf55e">&#9670;&nbsp;</a></span>axpy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmolpro_1_1SMat__.html">molpro::SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt;::axpy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmolpro_1_1SMat__.html#a0b0793833395ba3be28166f1d3921341">value_type</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmolpro_1_1SMat__.html">SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>axpy Constant times a matrix plus a matrix, y=y+a*x </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Constant to multiply <code>x</code> </td></tr>
    <tr><td class="paramname">x</td><td>Matrix to be added to <code>y</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae9ce68b6801a554e81f4408409bd737f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9ce68b6801a554e81f4408409bd737f">&#9670;&nbsp;</a></span>axpy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmolpro_1_1SMat__.html">molpro::SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt;::axpy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmolpro_1_1SMat__.html#a0b0793833395ba3be28166f1d3921341">value_type</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; size_t, <a class="el" href="classmolpro_1_1SMat__.html#a0b0793833395ba3be28166f1d3921341">value_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac645aaea1fb648500512ab87e7a727a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac645aaea1fb648500512ab87e7a727a6">&#9670;&nbsp;</a></span>block()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">molpro::array&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt; <a class="el" href="classmolpro_1_1SMat__.html">molpro::SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt;::block </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>block_symmetry</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a container pointing to a symmetry block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_symmetry</td><td>The symmetry of the row (first) index of the desired block </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector object containing the data </dd></dl>

</div>
</div>
<a id="ab93b3f5593b33760619295753b5d59d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab93b3f5593b33760619295753b5d59d5">&#9670;&nbsp;</a></span>block_dimensions()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; size_t &gt; <a class="el" href="classmolpro_1_1SMat__.html">molpro::SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt;::block_dimensions </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>block_symmetry</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the dimensions of a symmetry block in the buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_symmetry</td><td>The symmetry of the row (first) index of the desired block </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first two numbers returned are the numbers of rows and columns (Fortran convention). The third number is zero if the rows are drawn from <code>block_symmetry</code>, or 1 if the columns are drawn from <code>block_symmetry</code>, i.e. <a class="el" href="classmolpro_1_1SMat__.html#ab2bff361bef7e21e8d5559c84f1149e5" title="Whether or not a particular symmetry block is stored as the transpose.">block_transposed()</a>. </dd></dl>

</div>
</div>
<a id="a50567b48730e40fbc63a98c503412acc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50567b48730e40fbc63a98c503412acc">&#9670;&nbsp;</a></span>block_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classmolpro_1_1SMat__.html">molpro::SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt;::block_size </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>block_symmetry</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the size of a symmetry block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_symmetry</td><td>The symmetry of the row (first) index of the desired block </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The summed size of the symmetry block </dd></dl>

</div>
</div>
<a id="ab2bff361bef7e21e8d5559c84f1149e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2bff361bef7e21e8d5559c84f1149e5">&#9670;&nbsp;</a></span>block_transposed()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmolpro_1_1SMat__.html">molpro::SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt;::block_transposed </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>block_symmetry</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether or not a particular symmetry block is stored as the transpose. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_symmetry</td><td>The symmetry of the row (first) index of the desired block </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="aac569d073f21357ef567ef5117a0277f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac569d073f21357ef567ef5117a0277f">&#9670;&nbsp;</a></span>bytestream() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">molpro::bytestream <a class="el" href="classmolpro_1_1SMat__.html">molpro::SMat_</a>&lt; double &gt;::bytestream </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a957ab00af39f9506b9115df9cfacc561"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a957ab00af39f9506b9115df9cfacc561">&#9670;&nbsp;</a></span>bytestream() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">class molpro::bytestream <a class="el" href="classmolpro_1_1SMat__.html">molpro::SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt;::bytestream </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>data</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serialise the object to a stream of bytes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>If true, write out the data buffer as well as the meta-information </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the serialised representation of the object </dd></dl>

</div>
</div>
<a id="a8772e70926c11c6018ea80b84a2ba410"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8772e70926c11c6018ea80b84a2ba410">&#9670;&nbsp;</a></span>copy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmolpro_1_1SMat__.html">SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt; &amp; <a class="el" href="classmolpro_1_1SMat__.html">molpro::SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt;::copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmolpro_1_1SMat__.html">SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemolpro.html#a7a136b7a21c942e40967ed5bab20ff2e">dims_t</a>&#160;</td>
          <td class="paramname"><em>sourceOffset</em> = <code>{{0,&#160;0,&#160;0,&#160;0,&#160;0,&#160;0,&#160;0,&#160;0},&#160;{0,&#160;0,&#160;0,&#160;0,&#160;0,&#160;0,&#160;0,&#160;0}}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy an SMat, if necessary converting parity, and with the possibility of a positive offset in the source row and column indices. If the copy is from square to triangular, the parity of the result is enforced, ie half <code>in</code> plus or minus the transpose of <code>in</code> is constructed. If the dimensions of source and destination do not match, only addresses valid in source and destination will be copied. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The source of data. </td></tr>
    <tr><td class="paramname">sourceOffset</td><td>The offset in source data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the result </dd></dl>

</div>
</div>
<a id="a54ad673f1ae269ec9777255219d74d20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54ad673f1ae269ec9777255219d74d20">&#9670;&nbsp;</a></span>data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">molpro::array&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt; * <a class="el" href="classmolpro_1_1SMat__.html">molpro::SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt;::data</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain a pointer to the raw data. </p>
<p>The underlying data model is</p><ul>
<li>For <a class="el" href="classmolpro_1_1SMat__.html#a98d3aa28735f6b9767860241b411467d" title="The parity of the object.">parity()</a>==0 (neither symmetric or antisymmetric matrices),<ul>
<li>symmetry blocks appear in ascending order of, and are indexed by, the row index symmetry rs.</li>
<li>the symmetry of the column index is cs=rs^symmetry</li>
<li>within the symmetry block, the row index changes fastest, ie has stride 1, ie columns are stored contiguously.</li>
<li>If <a class="el" href="classmolpro_1_1SMat__.html#a6b326d37c967bd710614bfbfe5d9b039" title="Whether the SMat is transposed.">transposed()</a>, the data layout is that of the transpose of the matrix.</li>
</ul>
</li>
<li>For <a class="el" href="classmolpro_1_1SMat__.html#a98d3aa28735f6b9767860241b411467d" title="The parity of the object.">parity()</a>!=0 (symmetric or antisymmetric) and <a class="el" href="classmolpro_1_1SMat__.html#a547b277343b47bd508c8a1a9b8265917" title="return the symmetry of the object">symmetry()</a>==0,<ul>
<li>symmetry blocks appear in ascending order of, and are indexed by, the row index symmetry rs.</li>
<li>within the symmetry block, addressing is triangular, i.e. k*(k+1)/2+l with k &gt; l.</li>
</ul>
</li>
<li>For <a class="el" href="classmolpro_1_1SMat__.html#a98d3aa28735f6b9767860241b411467d" title="The parity of the object.">parity()</a>!=0 (symmetric or antisymmetric) and <a class="el" href="classmolpro_1_1SMat__.html#a547b277343b47bd508c8a1a9b8265917" title="return the symmetry of the object">symmetry()</a>!=0,<ul>
<li>only blocks with rs &gt; cs=rs^symmetry are actually stored, with the row index changing fastest, and column index having stride dimension(rs).</li>
<li>block_offset(rs) returns block_offset(cs) if rs &lt; cs. In this case, the implication is then that the column index changes fastest, i.e. row index stride is dimension(cs). This is signalled through <a class="el" href="classmolpro_1_1SMat__.html#ab2bff361bef7e21e8d5559c84f1149e5" title="Whether or not a particular symmetry block is stored as the transpose.">block_transposed()</a> delivering true.</li>
<li>In the case of <a class="el" href="classmolpro_1_1SMat__.html#a98d3aa28735f6b9767860241b411467d" title="The parity of the object.">parity()</a>&lt;0, the data stored are related to the actual data by a factor of -1 if <a class="el" href="classmolpro_1_1SMat__.html#ab2bff361bef7e21e8d5559c84f1149e5" title="Whether or not a particular symmetry block is stored as the transpose.">block_transposed()</a> != <a class="el" href="classmolpro_1_1SMat__.html#a6b326d37c967bd710614bfbfe5d9b039" title="Whether the SMat is transposed.">transposed()</a>. <dl class="section return"><dt>Returns</dt><dd>A pointer to the data buffer. </dd></dl>
</li>
</ul>
</li>
</ul>

</div>
</div>
<a id="a634e0ddc74bc09838dde93545085661f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a634e0ddc74bc09838dde93545085661f">&#9670;&nbsp;</a></span>desymmetrise()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmolpro_1_1SMat__.html">SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt; <a class="el" href="classmolpro_1_1SMat__.html">molpro::SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt;::desymmetrise</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Produce a copy of the object which has no symmetry. </p>

</div>
</div>
<a id="a202742845c62542a214f49fd56768b4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a202742845c62542a214f49fd56768b4b">&#9670;&nbsp;</a></span>Diagonal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmolpro_1_1SMat__.html">molpro::SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt;::Diagonal</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether the <a class="el" href="namespacemolpro.html#ad80f79742f183b105c60b295863d6718">SMat</a> is diagonal. </p>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a37d11915f8ea6ad10c476ec3370d1d33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37d11915f8ea6ad10c476ec3370d1d33">&#9670;&nbsp;</a></span>diagonal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmolpro_1_1SMat__.html">SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt; <a class="el" href="classmolpro_1_1SMat__.html">molpro::SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt;::diagonal</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a341a13f8db182f9827f4bda1160a287f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a341a13f8db182f9827f4bda1160a287f">&#9670;&nbsp;</a></span>dimension()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classmolpro_1_1SMat__.html">molpro::SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt;::dimension </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>block_symmetry</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>axis</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a dimension of a symmetry block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_symmetry</td><td>The symmetry of the row index </td></tr>
    <tr><td class="paramname">axis</td><td>0: number of rows ; 1: number of columns </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="ad6d93288414fcf17fe589aec43663ea6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6d93288414fcf17fe589aec43663ea6">&#9670;&nbsp;</a></span>dimensions()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemolpro.html#a7a136b7a21c942e40967ed5bab20ff2e">dims_t</a> <a class="el" href="classmolpro_1_1SMat__.html">molpro::SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt;::dimensions</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5ba0ca2bd576b95d256041c67aecfb74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ba0ca2bd576b95d256041c67aecfb74">&#9670;&nbsp;</a></span>dot() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmolpro_1_1SMat__.html#a8b8c1114d47d84f7d7ed2924fe11ed23">scalar_type</a> <a class="el" href="classmolpro_1_1SMat__.html">molpro::SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt;::dot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmolpro_1_1SMat__.html">SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a672d4f2699a86d74f2298ffaaa1ad28c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a672d4f2699a86d74f2298ffaaa1ad28c">&#9670;&nbsp;</a></span>dot() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmolpro_1_1SMat__.html#a8b8c1114d47d84f7d7ed2924fe11ed23">scalar_type</a> <a class="el" href="classmolpro_1_1SMat__.html">molpro::SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt;::dot </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; size_t, <a class="el" href="classmolpro_1_1SMat__.html#a0b0793833395ba3be28166f1d3921341">value_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2cdd0f1342f2969068b4ea38188a8906"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cdd0f1342f2969068b4ea38188a8906">&#9670;&nbsp;</a></span>ev() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classmolpro_1_1SMat__.html">molpro::SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt;::ev </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmolpro_1_1SMat__.html">SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmolpro_1_1SMat__.html">SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt; *&#160;</td>
          <td class="paramname"><em>vec</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmolpro_1_1SMat__.html">SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt; *&#160;</td>
          <td class="paramname"><em>vali</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmolpro_1_1SMat__.html">SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt; *&#160;</td>
          <td class="paramname"><em>vecl</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>algorithm</em> = <code>&quot;lapack&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>sort</em> = <code>&quot;ascending&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">\brief Find the eigenvalues and, optionally, eigenvectors
\param val The eigenvalues
\param vec The right eigenvectors
\param vali The imaginary part of the eigenvalues. Not used if matrix is symmetric. Not required if it turns out
</pre><p> that all the eigenvalues are real, but if supplied it will always be filled. If not supplied, but imaginary eigenvalues are found, an error is thrown. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vecl</td><td>The left eigenvectors </td></tr>
    <tr><td class="paramname">algorithm</td><td>'lapack' or 'jacobi' </td></tr>
    <tr><td class="paramname">sort</td><td>'ascending', 'descending' or 'overlap' </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If non-zero, an error code produced by Lapack dysev or dgeev </dd></dl>

</div>
</div>
<a id="a6beb9b03aa3126b8d2ebe6c4a0a8bee1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6beb9b03aa3126b8d2ebe6c4a0a8bee1">&#9670;&nbsp;</a></span>ev() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classmolpro_1_1SMat__.html">molpro::SMat_</a>&lt; double &gt;::ev </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmolpro_1_1SMat__.html">SMat_</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmolpro_1_1SMat__.html">SMat_</a>&lt; double &gt; *&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmolpro_1_1SMat__.html">SMat_</a>&lt; double &gt; *&#160;</td>
          <td class="paramname"><em>vali</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmolpro_1_1SMat__.html">SMat_</a>&lt; double &gt; *&#160;</td>
          <td class="paramname"><em>vecl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>algorithm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>sort</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a02746993eafa2f8bc9c473a7bf7faba1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02746993eafa2f8bc9c473a7bf7faba1">&#9670;&nbsp;</a></span>eval()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmolpro_1_1SMat__.html">molpro::SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt;::eval</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate, including explicitly transposing if necessary. </p>

</div>
</div>
<a id="a6b3a87a915e32f5ed1adf37c5ad117dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b3a87a915e32f5ed1adf37c5ad117dd">&#9670;&nbsp;</a></span>exp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmolpro_1_1SMat__.html">SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt; <a class="el" href="classmolpro_1_1SMat__.html">molpro::SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt;::exp</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the exponential of a matrix. </p>

</div>
</div>
<a id="a847253cb6a578d49a64612400309bd67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a847253cb6a578d49a64612400309bd67">&#9670;&nbsp;</a></span>fill()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmolpro_1_1SMat__.html">molpro::SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt;::fill </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmolpro_1_1SMat__.html#a0b0793833395ba3be28166f1d3921341">value_type</a>&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign a single scalar value to all elements of the matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>the value to fill </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4e7dfbc96ba45996acb36ba60efdda5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e7dfbc96ba45996acb36ba60efdda5e">&#9670;&nbsp;</a></span>inverse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmolpro_1_1SMat__.html">SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt; <a class="el" href="classmolpro_1_1SMat__.html">molpro::SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt;::inverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmolpro_1_1SMat__.html#a8b8c1114d47d84f7d7ed2924fe11ed23">scalar_type</a>&#160;</td>
          <td class="paramname"><em>SVThresh</em> = <code>0.0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the inverse of a matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">SVThresh</td><td>if specified, calculate the pseudoinverse via the singular-value decomposition of the matrix, ignoring contributions from all singular values less than this parameter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The inverse </dd></dl>

</div>
</div>
<a id="a503cdf456709343ea17fc813454caddf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a503cdf456709343ea17fc813454caddf">&#9670;&nbsp;</a></span>log()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmolpro_1_1SMat__.html">SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt; <a class="el" href="classmolpro_1_1SMat__.html">molpro::SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt;::log</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the logarithm of a matrix. </p>

</div>
</div>
<a id="a8539a7cb4cbe5a826ab5702b692565f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8539a7cb4cbe5a826ab5702b692565f2">&#9670;&nbsp;</a></span>max_symmetry()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classmolpro_1_1SMat__.html">molpro::SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt;::max_symmetry</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The maximum symmetry of the object, i.e. the symmetry index above which all dimensions are zero and are impossible to reach by direct products. </p>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a45ef1bf1087620d03f86ee3c8f111671"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45ef1bf1087620d03f86ee3c8f111671">&#9670;&nbsp;</a></span>multiply()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmolpro_1_1SMat__.html">molpro::SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt;::multiply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmolpro_1_1SMat__.html">SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmolpro_1_1SMat__.html">SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmolpro_1_1SMat__.html#a0b0793833395ba3be28166f1d3921341">value_type</a>&#160;</td>
          <td class="paramname"><em>alpha</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmolpro_1_1SMat__.html#a0b0793833395ba3be28166f1d3921341">value_type</a>&#160;</td>
          <td class="paramname"><em>beta</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply two SMat objects with contraction such that the result is another SMat, which will be placed in the current object, which must have the correct dimensions. Depending on the ranks of the sources, the possible paradigms are. </p>
<ul>
<li>this(i,k) = beta*this(i,k) + alpha*a(i,j)*b(j,k)</li>
<li>this(i) = beta*this(i) + alpha*a(i,j)*b(j)</li>
<li>this(k) = beta*this(k) + alpha*a(j)*b(j,k)</li>
<li>this(j,k) = beta*this(j,k) + alpha*a(j)*b(k) <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The first matrix in the product. </td></tr>
    <tr><td class="paramname">b</td><td>The second matrix in the product. </td></tr>
    <tr><td class="paramname">alpha</td><td>Factor to multiply a*b. </td></tr>
    <tr><td class="paramname">beta</td><td>The fraction of the current object to add to the product. </td></tr>
  </table>
  </dd>
</dl>
</li>
</ul>

</div>
</div>
<a id="a87da40b6dc99e6121a56a268e5cb7d89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87da40b6dc99e6121a56a268e5cb7d89">&#9670;&nbsp;</a></span>norm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmolpro_1_1SMat__.html">SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt;::<a class="el" href="classmolpro_1_1SMat__.html#a8b8c1114d47d84f7d7ed2924fe11ed23">scalar_type</a> <a class="el" href="classmolpro_1_1SMat__.html">molpro::SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt;::norm</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the norm. For vectors, it is the L2-norm; for matrices, the square root of the sum of the matrix elements. </p>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a8cb7ca96f47fff37ac68d4fa86ef9118"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cb7ca96f47fff37ac68d4fa86ef9118">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmolpro_1_1SMat__.html">molpro::SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmolpro_1_1SMat__.html">SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acb9f39683496e90b66f1a5a2f30a6347"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb9f39683496e90b66f1a5a2f30a6347">&#9670;&nbsp;</a></span>operator&amp;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmolpro_1_1SMat__.html">SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt;::<a class="el" href="classmolpro_1_1SMat__.html#a8b8c1114d47d84f7d7ed2924fe11ed23">scalar_type</a> <a class="el" href="classmolpro_1_1SMat__.html">molpro::SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt;::operator&amp; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmolpro_1_1SMat__.html">SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply two SMat objects with contraction such that the result is a scalar scalar_type. Depending on the ranks of the sources, the possible paradigms are. </p>
<ul>
<li>this(i,j)*other(j,i)</li>
<li>this(j)*other(j) <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The matrix to postmultiply with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the scalar contraction of the two matrices. </dd></dl>
</li>
</ul>

</div>
</div>
<a id="a5accc02756a9ed0c1f49a98a8d88704b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5accc02756a9ed0c1f49a98a8d88704b">&#9670;&nbsp;</a></span>operator*() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classmolpro_1_1SMat__.html">SMat_</a> <a class="el" href="classmolpro_1_1SMat__.html">molpro::SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt;::operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmolpro_1_1SMat__.html">SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply two SMat objects with contraction such that the result is another SMat. Depending on the ranks of the sources, the possible paradigms are. </p>
<ul>
<li>this(i,j)*other(j,k)</li>
<li>this(i,j)*other(j)</li>
<li>this(j)*other(j,k)</li>
<li>this(j)*other(k) <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The matrix to postmultiply with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new SMat containing the product. </dd></dl>
</li>
</ul>

</div>
</div>
<a id="a209f34cc5b42189ac62b3b37d4f38ecf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a209f34cc5b42189ac62b3b37d4f38ecf">&#9670;&nbsp;</a></span>operator*() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classmolpro_1_1SMat__.html">SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt; <a class="el" href="classmolpro_1_1SMat__.html">molpro::SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt;::operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmolpro_1_1SMat__.html#a0b0793833395ba3be28166f1d3921341">value_type</a>&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a212e6a6d64b026ba600d5ea713c78604"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a212e6a6d64b026ba600d5ea713c78604">&#9670;&nbsp;</a></span>operator*=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmolpro_1_1SMat__.html">SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt; &amp; <a class="el" href="classmolpro_1_1SMat__.html">molpro::SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmolpro_1_1SMat__.html#a0b0793833395ba3be28166f1d3921341">value_type</a>&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa584ea3281c6576f0c07bb5de13430f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa584ea3281c6576f0c07bb5de13430f0">&#9670;&nbsp;</a></span>operator+()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classmolpro_1_1SMat__.html">SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt; <a class="el" href="classmolpro_1_1SMat__.html">molpro::SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt;::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmolpro_1_1SMat__.html">SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a41ad7a4c85c10e0964c02b18d1a93ec7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41ad7a4c85c10e0964c02b18d1a93ec7">&#9670;&nbsp;</a></span>operator+=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmolpro_1_1SMat__.html">SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt; &amp; <a class="el" href="classmolpro_1_1SMat__.html">molpro::SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmolpro_1_1SMat__.html">SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0db33e2542b6c7dd946fc3078b7fe337"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0db33e2542b6c7dd946fc3078b7fe337">&#9670;&nbsp;</a></span>operator-()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classmolpro_1_1SMat__.html">SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt; <a class="el" href="classmolpro_1_1SMat__.html">molpro::SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt;::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmolpro_1_1SMat__.html">SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a085817f06053ef9175e2b6d065fec4c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a085817f06053ef9175e2b6d065fec4c5">&#9670;&nbsp;</a></span>operator-=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmolpro_1_1SMat__.html">SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt; &amp; <a class="el" href="classmolpro_1_1SMat__.html">molpro::SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmolpro_1_1SMat__.html">SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af98b315200c9f4b18ae4dd4737636371"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af98b315200c9f4b18ae4dd4737636371">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmolpro_1_1SMat__.html">SMat_</a>&lt;<a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a>&gt;&amp; <a class="el" href="classmolpro_1_1SMat__.html">molpro::SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; size_t, <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a101b66c8de2e0ebf4525078e77c02102"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a101b66c8de2e0ebf4525078e77c02102">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmolpro_1_1SMat__.html">SMat_</a>&amp; <a class="el" href="classmolpro_1_1SMat__.html">molpro::SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmolpro_1_1SMat__.html">SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy an SMat, if necessary converting parity. If the copy is from square to triangular, the parity of the result is enforced, ie half <code>in</code> plus or minus the transpose of <code>in</code> is constructed. If the dimensions of source and destination do not match, only addresses valid in source and destination will be copied. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The source of data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the result </dd></dl>

</div>
</div>
<a id="a96a34d65a3c485318a1d38a7b185b326"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96a34d65a3c485318a1d38a7b185b326">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmolpro_1_1SMat__.html">molpro::SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmolpro_1_1SMat__.html">SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test whether two objects are equal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a02a41573d916efcca2e28475ce243b01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02a41573d916efcca2e28475ce243b01">&#9670;&nbsp;</a></span>orthogonalize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmolpro_1_1SMat__.html">molpro::SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt;::orthogonalize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmolpro_1_1SMat__.html">SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt; *&#160;</td>
          <td class="paramname"><em>metric</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>algorithm</em> = <code>&quot;Gram-Schmidt&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Orthonormalize the columns of the matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">metric</td><td>The metric, defaulting to unit matrix </td></tr>
    <tr><td class="paramname">algorithm</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a98d3aa28735f6b9767860241b411467d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98d3aa28735f6b9767860241b411467d">&#9670;&nbsp;</a></span>parity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemolpro.html#a77b8d977180296c55c184036b65c5a6f">parity_t</a> <a class="el" href="classmolpro_1_1SMat__.html">molpro::SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt;::parity</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The parity of the object. </p>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="ac352224d7a7d8b5643b51c497cef187b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac352224d7a7d8b5643b51c497cef187b">&#9670;&nbsp;</a></span>pow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmolpro_1_1SMat__.html">SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt; <a class="el" href="classmolpro_1_1SMat__.html">molpro::SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt;::pow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmolpro_1_1SMat__.html#a0b0793833395ba3be28166f1d3921341">value_type</a>&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate a power of a matrix. </p>

</div>
</div>
<a id="a1afadd176dc7464b07ba2e3b7910f0d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1afadd176dc7464b07ba2e3b7910f0d7">&#9670;&nbsp;</a></span>rank()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classmolpro_1_1SMat__.html">molpro::SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt;::rank</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the rank of the object. </p>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="aa0403579ec286fa82bba55b4dc50249c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0403579ec286fa82bba55b4dc50249c">&#9670;&nbsp;</a></span>scal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmolpro_1_1SMat__.html">molpro::SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt;::scal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmolpro_1_1SMat__.html#a0b0793833395ba3be28166f1d3921341">value_type</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>scaleDiagonal</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>scal: Scale a matrix by a constant </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>the constant factor </td></tr>
    <tr><td class="paramname">scaleDiagonal</td><td>If false, then do not touch the diagonal elements. The matrix has to be square for this to make sense. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acf2c94dde6a37469cfd6787c9921ab89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf2c94dde6a37469cfd6787c9921ab89">&#9670;&nbsp;</a></span>select()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt;std::vector&lt;size_t&gt;, std::vector&lt;<a class="el" href="classmolpro_1_1SMat__.html#a0b0793833395ba3be28166f1d3921341">value_type</a>&gt; &gt; <a class="el" href="classmolpro_1_1SMat__.html">molpro::SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt;::select </td>
          <td>(</td>
          <td class="paramtype">const molpro::array&lt; <a class="el" href="classmolpro_1_1SMat__.html#a0b0793833395ba3be28166f1d3921341">value_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>measure</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>maximumNumber</em> = <code>1000</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmolpro_1_1SMat__.html#a8b8c1114d47d84f7d7ed2924fe11ed23">scalar_type</a>&#160;</td>
          <td class="paramname"><em>threshold</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0f0818703e5fd58522ef17775f5b5d0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f0818703e5fd58522ef17775f5b5d0a">&#9670;&nbsp;</a></span>select_max_dot() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;size_t, <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a>&gt; <a class="el" href="classmolpro_1_1SMat__.html">molpro::SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt;::select_max_dot </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmolpro_1_1SMat__.html">SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa4bf47ca6cca88fa5459d23462d93e1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4bf47ca6cca88fa5459d23462d93e1e">&#9670;&nbsp;</a></span>select_max_dot() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;size_t, <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a>&gt; <a class="el" href="classmolpro_1_1SMat__.html">molpro::SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt;::select_max_dot </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; size_t, <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3b183f6027e4dd11375d990fb8d7f008"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b183f6027e4dd11375d990fb8d7f008">&#9670;&nbsp;</a></span>setIdentity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmolpro_1_1SMat__.html">molpro::SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt;::setIdentity</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set equal to the unit matrix. </p>

</div>
</div>
<a id="a991324ba20fa8d9dfedd0e39570e7d5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a991324ba20fa8d9dfedd0e39570e7d5e">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classmolpro_1_1SMat__.html">molpro::SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt;::size</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the buffer size of an <a class="el" href="namespacemolpro.html#ad80f79742f183b105c60b295863d6718">SMat</a> object. </p>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="aa430910cb57918a059992d8e1345e5f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa430910cb57918a059992d8e1345e5f2">&#9670;&nbsp;</a></span>slice()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmolpro_1_1SMat__.html">SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt; <a class="el" href="classmolpro_1_1SMat__.html">molpro::SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt;::slice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemolpro.html#a7a136b7a21c942e40967ed5bab20ff2e">dims_t</a>&#160;</td>
          <td class="paramname"><em>dimensions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemolpro.html#a7a136b7a21c942e40967ed5bab20ff2e">dims_t</a>&#160;</td>
          <td class="paramname"><em>offset</em> = <code>{{0,&#160;0,&#160;0,&#160;0,&#160;0,&#160;0,&#160;0,&#160;0},&#160;{0,&#160;0,&#160;0,&#160;0,&#160;0,&#160;0,&#160;0,&#160;0}}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>description</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a new SMat as a copy of a submatrix of this one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dimensions</td><td>dimensions of new matrix </td></tr>
    <tr><td class="paramname">offset</td><td>offsets in this for the start of the result </td></tr>
    <tr><td class="paramname">description</td><td>A string describing the object. Defaults to this-&gt;m_description. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new matrix </dd></dl>

</div>
</div>
<a id="aaeced17693b785a25d29c67350865961"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaeced17693b785a25d29c67350865961">&#9670;&nbsp;</a></span>solve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmolpro_1_1SMat__.html">SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt; <a class="el" href="classmolpro_1_1SMat__.html">molpro::SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt;::solve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmolpro_1_1SMat__.html">SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>algorithm</em> = <code>&quot;ColPivHouseholderQR&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solve one or more linear equation systems, where the current matrix is the coefficient matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td></td></tr>
    <tr><td class="paramname">algorithm</td><td>One of the following, as described in the documentation for Eigen.<ul>
<li>"partialPivLu"</li>
<li>"FullPivLU"</li>
<li>"HouseholderQR"</li>
<li>"ColPivHouseholderQR"</li>
<li>"FullPivHouseholderQR"</li>
<li>"LLT"</li>
<li>"LDLT" </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a5d0e1b4ebd809e20903c469937e6037a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d0e1b4ebd809e20903c469937e6037a">&#9670;&nbsp;</a></span>splice()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmolpro_1_1SMat__.html">molpro::SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt;::splice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmolpro_1_1SMat__.html">SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemolpro.html#a7a136b7a21c942e40967ed5bab20ff2e">dims_t</a>&#160;</td>
          <td class="paramname"><em>sourceOffset</em> = <code>{{0,&#160;0,&#160;0,&#160;0,&#160;0,&#160;0,&#160;0,&#160;0},&#160;{0,&#160;0,&#160;0,&#160;0,&#160;0,&#160;0,&#160;0,&#160;0}}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemolpro.html#a7a136b7a21c942e40967ed5bab20ff2e">dims_t</a>&#160;</td>
          <td class="paramname"><em>offset</em> = <code>{{0,&#160;0,&#160;0,&#160;0,&#160;0,&#160;0,&#160;0,&#160;0},&#160;{0,&#160;0,&#160;0,&#160;0,&#160;0,&#160;0,&#160;0,&#160;0}}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy part or all of another SMat object, corresponding to a reduced range of indices, into this one. The copy range for either rows or columns is restricted so that it lies within both the source and destination. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>Another SMat of any dimensions </td></tr>
    <tr><td class="paramname">sourceOffset</td><td>Row and column index offsets for source </td></tr>
    <tr><td class="paramname">offset</td><td>Row and column index offsets for *this </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0f86776d92d5cf9667606b39525f9d40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f86776d92d5cf9667606b39525f9d40">&#9670;&nbsp;</a></span>sqrt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmolpro_1_1SMat__.html">SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt; <a class="el" href="classmolpro_1_1SMat__.html">molpro::SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt;::sqrt</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the square root of a matrix. </p>

</div>
</div>
<a id="af00df9fde8fd27b222612b604cec0aaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af00df9fde8fd27b222612b604cec0aaf">&#9670;&nbsp;</a></span>str() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classmolpro_1_1SMat__.html">molpro::SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt;::str </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>verbosity</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>columns</em> = <code>UINT_MAX</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2a2f0729c8d277b56aac40f0fc9801d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a2f0729c8d277b56aac40f0fc9801d8">&#9670;&nbsp;</a></span>str() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classmolpro_1_1SMat__.html">molpro::SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt;::str </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>title</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>precision</em> = <code>Eigen::StreamPrecision</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a printable summary of the object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">title</td><td>Any desired title </td></tr>
    <tr><td class="paramname">level</td><td>Amount of information to report </td></tr>
    <tr><td class="paramname">precision</td><td>How many digits to show </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a547b277343b47bd508c8a1a9b8265917"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a547b277343b47bd508c8a1a9b8265917">&#9670;&nbsp;</a></span>symmetry()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classmolpro_1_1SMat__.html">molpro::SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt;::symmetry</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the symmetry of the object </p>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a5f9e9a4b80130050227a951867384dd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f9e9a4b80130050227a951867384dd3">&#9670;&nbsp;</a></span>trace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> <a class="el" href="classmolpro_1_1SMat__.html">molpro::SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt;::trace</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the trace of a matrix. </p>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a572642adea5faac95ffde6488280dc3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a572642adea5faac95ffde6488280dc3c">&#9670;&nbsp;</a></span>transform()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmolpro_1_1SMat__.html">SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt; <a class="el" href="classmolpro_1_1SMat__.html">molpro::SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt;::transform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmolpro_1_1SMat__.html">SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>orthogonal</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a similarity transformation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>the transformation matrix </td></tr>
    <tr><td class="paramname">orthogonal</td><td>Whether or not to assume that q is an orthogonal matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>transpose(q)*this*q </dd></dl>

</div>
</div>
<a id="aa878713a29c0844e2cd3872156a3bc30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa878713a29c0844e2cd3872156a3bc30">&#9670;&nbsp;</a></span>transpose()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmolpro_1_1SMat__.html">molpro::SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt;::transpose</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transpose the object. The implementation does not touch the data, but internally marks the state as transposed, affecting the results of subsequent calls to <a class="el" href="classmolpro_1_1SMat__.html#ab2bff361bef7e21e8d5559c84f1149e5" title="Whether or not a particular symmetry block is stored as the transpose.">block_transposed()</a> and <a class="el" href="classmolpro_1_1SMat__.html#ab93b3f5593b33760619295753b5d59d5" title="Get the dimensions of a symmetry block in the buffer.">block_dimensions()</a>. </p>

</div>
</div>
<a id="a6b326d37c967bd710614bfbfe5d9b039"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b326d37c967bd710614bfbfe5d9b039">&#9670;&nbsp;</a></span>transposed()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmolpro_1_1SMat__.html">molpro::SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt;::transposed</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether the <a class="el" href="namespacemolpro.html#ad80f79742f183b105c60b295863d6718">SMat</a> is transposed. </p>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a2942690c1327698fa56541091033d9b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2942690c1327698fa56541091033d9b4">&#9670;&nbsp;</a></span>trim()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmolpro_1_1SMat__.html">molpro::SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt;::trim </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmolpro_1_1SMat__.html#a8b8c1114d47d84f7d7ed2924fe11ed23">scalar_type</a>&#160;</td>
          <td class="paramname"><em>cut</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set to zero all elements of the object whose absolute value is less than a specified threshold. </p>
<p>cut The threshold. Defaults to machine epsilon. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a40c0103547dd73b67fe34b59e58c6bc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40c0103547dd73b67fe34b59e58c6bc8">&#9670;&nbsp;</a></span>m_description</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classmolpro_1_1SMat__.html">molpro::SMat_</a>&lt; <a class="el" href="Operator-double_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt;::m_description</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A string describing the object. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/__w/gci/gci/src/molpro/symmetry_matrix/<a class="el" href="SMat_8h_source.html">SMat.h</a></li>
<li>/__w/gci/gci/src/molpro/symmetry_matrix/<a class="el" href="SMat-implementation_8h_source.html">SMat-implementation.h</a></li>
<li>/__w/gci/gci/src/molpro/symmetry_matrix/<a class="el" href="SMat-double_8cpp.html">SMat-double.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
